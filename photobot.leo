<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="karstenw.20170709210040.1" a="E"><vh>@clean photobot/__init__.py</vh>
<v t="karstenw.20170709210125.1"><vh>Declarations</vh></v>
<v t="karstenw.20200421130950.1"><vh>Globals</vh></v>
<v t="karstenw.20200419210659.1" a="E"><vh>Photobot</vh>
<v t="karstenw.20170709210125.5" a="E"><vh>class Canvas</vh>
<v t="karstenw.20170709210125.6"><vh>__init__</vh></v>
<v t="karstenw.20170709210125.7"><vh>layer</vh></v>
<v t="karstenw.20170709210125.8"><vh>fill</vh></v>
<v t="karstenw.20170709210125.9"><vh>makegradientimage</vh></v>
<v t="karstenw.20170709210125.10"><vh>gradient</vh></v>
<v t="karstenw.20170709210125.11"><vh>merge</vh></v>
<v t="karstenw.20170709210125.12"><vh>flatten</vh></v>
<v t="karstenw.20170709210125.13"><vh>export</vh>
<v t="karstenw.20200430120922.1"><vh>&lt;&lt;init&gt;&gt;</vh></v>
<v t="karstenw.20200430120955.1"><vh>&lt;&lt;debug&gt;&gt;</vh></v>
</v>
<v t="karstenw.20170709210125.14"><vh>draw</vh></v>
<v t="karstenw.20170709210125.15"><vh>preferences</vh></v>
<v t="karstenw.20200430120743.1"><vh>STACK OPS</vh>
<v t="karstenw.20170710142919.1"><vh>top</vh></v>
<v t="karstenw.20200430124808.1"><vh>dup</vh></v>
<v t="karstenw.20200430120752.1"><vh>ops</vh></v>
</v>
</v>
<v t="karstenw.20170709210125.16"><vh>canvas</vh></v>
<v t="karstenw.20170709210125.17"><vh>class Layers</vh>
<v t="karstenw.20170709210125.18"><vh>__getitem__</vh></v>
<v t="karstenw.20170709210125.19"><vh>_get_bg</vh></v>
<v t="karstenw.20170709210125.20"><vh>_set_bg</vh></v>
</v>
<v t="karstenw.20170709210125.21"><vh>class Layer</vh>
<v t="karstenw.20170709210125.22"><vh>__init__</vh></v>
<v t="karstenw.20170709210125.23"><vh>prnt</vh></v>
<v t="karstenw.20170709210125.24"><vh>index</vh></v>
<v t="karstenw.20170709210125.25"><vh>copy</vh></v>
<v t="karstenw.20170709210125.26"><vh>delete</vh></v>
<v t="karstenw.20170709210125.27"><vh>up</vh></v>
<v t="karstenw.20170709210125.28"><vh>down</vh></v>
<v t="karstenw.20170709210125.29"><vh>bounds</vh></v>
<v t="karstenw.20170709210125.30"><vh>select</vh></v>
<v t="karstenw.20170709210125.31"><vh>mask</vh></v>
<v t="karstenw.20170709210125.32"><vh>duplicate</vh></v>
<v t="karstenw.20170727231803.1"><vh>BLENDS</vh>
<v t="karstenw.20170709210125.33"><vh>opacity</vh></v>
<v t="karstenw.20170709210125.34"><vh>multiply</vh></v>
<v t="karstenw.20200419182817.1"><vh>add</vh></v>
<v t="karstenw.20200419182824.1"><vh>subtract</vh></v>
<v t="karstenw.20200419182831.1"><vh>add_modulo</vh></v>
<v t="karstenw.20200419182838.1"><vh>subtract_modulo</vh></v>
<v t="karstenw.20200419182844.1"><vh>difference</vh></v>
<v t="karstenw.20170709210125.35"><vh>screen</vh></v>
<v t="karstenw.20170709210125.36"><vh>overlay</vh></v>
<v t="karstenw.20170709210125.37"><vh>hue</vh></v>
<v t="karstenw.20170709210125.38"><vh>color</vh></v>
</v>
<v t="karstenw.20170727231827.1"><vh>INTENSITIES</vh>
<v t="karstenw.20170709210125.39"><vh>brightness</vh></v>
<v t="karstenw.20170709210125.40"><vh>contrast</vh></v>
<v t="karstenw.20170709210125.41"><vh>desaturate</vh></v>
<v t="karstenw.20170709210125.42"><vh>colorize</vh></v>
</v>
<v t="karstenw.20170709210125.43"><vh>invert</vh></v>
<v t="karstenw.20170727232236.1"><vh>GEOMETRY</vh>
<v t="karstenw.20170709210125.44"><vh>translate</vh></v>
<v t="karstenw.20170709210125.45"><vh>scale</vh></v>
<v t="karstenw.20170709210125.47"><vh>rotate</vh></v>
<v t="karstenw.20170709210125.46"><vh>distort</vh></v>
<v t="karstenw.20170709210125.48"><vh>flip</vh></v>
<v t="karstenw.20170727233343.1"><vh>crop</vh></v>
</v>
<v t="karstenw.20200421172034.1"><vh>FILTERS</vh>
<v t="karstenw.20170727232434.1"><vh>autocontrast</vh></v>
<v t="karstenw.20170709210125.49"><vh>blur</vh></v>
<v t="karstenw.20200421172500.1"><vh>new boxblur</vh></v>
<v t="karstenw.20200419183112.1"><vh>new contour</vh></v>
<v t="karstenw.20200419183129.1"><vh>new detail</vh></v>
<v t="karstenw.20200419183142.1"><vh>new edge_enhance</vh></v>
<v t="karstenw.20200419183156.1"><vh>new edge_enhance_more</vh></v>
<v t="karstenw.20200419183210.1"><vh>new emboss</vh></v>
<v t="karstenw.20200419183218.1"><vh>new find_edges</vh></v>
<v t="karstenw.20200419183225.1"><vh>new smooth</vh></v>
<v t="karstenw.20200419183232.1"><vh>new smooth_more</vh></v>
<v t="karstenw.20170709210125.50"><vh>sharpen</vh></v>
<v t="karstenw.20200421172203.1"><vh>convolute</vh></v>
</v>
<v t="karstenw.20170709210125.51"><vh>statistics</vh></v>
<v t="karstenw.20170709210125.52"><vh>levels</vh></v>
</v>
<v t="karstenw.20170709210125.53"><vh>class Blend</vh>
<v t="karstenw.20170709210125.54"><vh>overlay</vh></v>
<v t="karstenw.20170709210125.55"><vh>hue</vh></v>
<v t="karstenw.20170709210125.56"><vh>color</vh></v>
</v>
<v t="karstenw.20170709210125.57"><vh>class Pixels</vh>
<v t="karstenw.20170709210125.58"><vh>__init__</vh></v>
<v t="karstenw.20170709210125.59"><vh>__getitem__</vh></v>
<v t="karstenw.20170709210125.60"><vh>__setitem__</vh></v>
<v t="karstenw.20170709210125.61"><vh>__iter__</vh></v>
<v t="karstenw.20170709210125.62"><vh>__len__</vh></v>
<v t="karstenw.20170709210125.63"><vh>update</vh></v>
<v t="karstenw.20170709210125.64"><vh>convolute</vh></v>
</v>
</v>
<v t="karstenw.20200419183424.1"><vh>Tools</vh>
<v t="karstenw.20200419185608.1"><vh>makeunicode</vh></v>
<v t="karstenw.20200419185543.1"><vh>hashFromString</vh></v>
<v t="karstenw.20200419185624.1"><vh>datestring</vh></v>
</v>
<v t="karstenw.20201022144341.1"><vh>Imagetools</vh>
<v t="karstenw.20200419184424.1"><vh>invertimage</vh></v>
<v t="karstenw.20200419184433.1"><vh>cropimage</vh></v>
<v t="karstenw.20170709210125.65"><vh>aspectRatio</vh></v>
<v t="karstenw.20201022144702.1"><vh>innerRect</vh></v>
<v t="karstenw.20170709210125.66"><vh>normalizeOrientationImage</vh></v>
<v t="karstenw.20200419185026.1"><vh>insetRect</vh></v>
<v t="karstenw.20200419185034.1"><vh>cropImageToRatioHorizontal</vh></v>
<v t="karstenw.20200419185042.1"><vh>scaleLayerToHeight</vh></v>
<v t="karstenw.20200419185049.1"><vh>placeImage</vh></v>
<v t="karstenw.20200419185056.1"><vh>resizeImage</vh></v>
<v t="karstenw.20200419184336.1"><vh>label</vh></v>
<v t="karstenw.20200419185227.1"><vh>filelist</vh></v>
<v t="karstenw.20200419185246.1"><vh>imagefiles</vh></v>
</v>
<v t="karstenw.20200419205343.1"><vh>ImageWell</vh>
<v t="karstenw.20170709210125.67"><vh>imagewells</vh></v>
<v t="karstenw.20200419185716.1"><vh>loadImageWell</vh></v>
</v>
<v t="karstenw.20201009153259.1"><vh>Image Sectors</vh>
<v t="karstenw.20201010122613.1"><vh>TiledImage</vh>
<v t="karstenw.20201010122902.1"><vh>__init__</vh></v>
<v t="karstenw.20201010123021.1"><vh>makeimage</vh></v>
</v>
</v>
<v t="karstenw.20201009153305.1"><vh>Canvas layout</vh>
<v t="karstenw.20201010124204.1" a="E"><vh>Layout</vh>
<v t="karstenw.20201010124230.1"><vh>__init__</vh></v>
</v>
</v>
</v>
<v t="karstenw.20210211171614.1"><vh>@clean photobot/squeaklib.py</vh>
<v t="karstenw.20210211171734.1"><vh>declarations</vh></v>
<v t="karstenw.20210211171653.1"><vh>Squeaklib</vh>
<v t="karstenw.20210216164600.1"><vh>tools</vh>
<v t="karstenw.20210216164604.1"><vh>makePoint</vh></v>
</v>
<v t="karstenw.20210211171653.2"><vh>Point</vh>
<v t="karstenw.20210211171653.3"><vh>__init__ __repr__</vh></v>
<v t="karstenw.20210213125927.1"><vh>__lt|le|gt|ge|eq|ne|add|sub|mul__</vh></v>
<v t="karstenw.20210217123206.1"><vh>isZero rounded truncateTo truncated</vh></v>
<v t="karstenw.20210217133714.1"><vh>converting (asFloatPoint asIntegerPoint corner extent isPoint rect)</vh></v>
<v t="karstenw.20210217133725.1"><vh>copying</vh></v>
<v t="karstenw.20210217134011.1"><vh>geometry</vh></v>
<v t="karstenw.20210217134045.1"><vh>point functions</vh></v>
<v t="karstenw.20210217134139.1"><vh>polar coordinates</vh></v>
<v t="karstenw.20210217134254.1"><vh>private</vh></v>
<v t="karstenw.20210217134318.1"><vh>transforming</vh></v>
<v t="karstenw.20210217134349.1"><vh>truncation and round off</vh></v>
<v t="karstenw.20210217134419.1"><vh>testing</vh></v>
</v>
<v t="karstenw.20210211171653.5"><vh>Rectangle</vh>
<v t="karstenw.20210211171653.6"><vh>__init__</vh></v>
<v t="karstenw.20210216174810.1"><vh>__eq|ne__</vh></v>
<v t="karstenw.20210211171653.7" a="E"><vh>properties</vh>
<v t="karstenw.20210216165734.1"><vh>origin corner</vh></v>
<v t="karstenw.20210216165815.1"><vh>height width area</vh></v>
<v t="karstenw.20210216165832.1"><vh>top left bottom right</vh></v>
<v t="karstenw.20210216170708.1"><vh>topleft topright bottomleft bottomright</vh></v>
<v t="karstenw.20210216170803.1"><vh>center</vh></v>
<v t="karstenw.20210216171723.1"><vh>bottomcenter topcenter leftcenter rightcenter</vh></v>
<v t="karstenw.20210216171724.1"><vh>corners extent</vh></v>
<v t="karstenw.20210216171724.2"><vh>newHeadline</vh></v>
<v t="karstenw.20210216171724.3"><vh>newHeadline</vh></v>
<v t="karstenw.20210216171724.4"><vh>newHeadline</vh></v>
<v t="karstenw.20210216171724.5"><vh>newHeadline</vh></v>
</v>
<v t="karstenw.20210211171653.8" a="E"><vh>class methods</vh>
<v t="karstenw.20210211171653.9"><vh>centerExtent originExtent</vh></v>
<v t="karstenw.20210211171653.10"><vh>leftRightTopBottom</vh></v>
</v>
<v t="karstenw.20210211171653.11" a="E"><vh>instance methods</vh>
<v t="karstenw.20210211171653.12"><vh>rectangle methods</vh></v>
<v t="karstenw.20210217105319.1"><vh>testing</vh></v>
<v t="karstenw.20210217132749.1"><vh>transforming</vh></v>
<v t="karstenw.20210211171653.13"><vh>inRect</vh></v>
</v>
</v>
</v>
</v>
<v t="karstenw.20210225165613.1"><vh>@clean photobot/blitter.py</vh>
<v t="karstenw.20210225165700.1"><vh>declarations</vh></v>
<v t="karstenw.20210225165727.1"><vh>BitBlt</vh>
<v t="karstenw.20210225165727.2"><vh>class comment</vh></v>
<v t="karstenw.20210225165727.3"><vh>class methods</vh>
<v t="karstenw.20210225165727.4"><vh>instance creation</vh></v>
<v t="karstenw.20210225165727.5"><vh>examples</vh></v>
<v t="karstenw.20210225165727.6"><vh>private</vh></v>
<v t="karstenw.20210225165727.7"><vh>benchmarks</vh></v>
</v>
<v t="karstenw.20210225165727.8"><vh>instance methods</vh>
<v t="karstenw.20210225165727.9"><vh>accessing</vh></v>
<v t="karstenw.20210225165727.10"><vh>copying</vh></v>
<v t="karstenw.20210225165727.11"><vh>line drawing</vh></v>
<v t="karstenw.20210225165727.12"><vh>private</vh></v>
</v>
<v t="karstenw.20210225165727.13"><vh>__init__</vh></v>
</v>
<v t="karstenw.20210225165643.1"><vh>newHeadline</vh></v>
</v>
<v t="karstenw.20201006211515.1"><vh>examples</vh>
<v t="karstenw.20201006211521.1"><vh>@clean examples/Example collage 1.py</vh>
<v t="karstenw.20201006211613.1"><vh>Declarations</vh></v>
<v t="karstenw.20201006211627.1"><vh>init</vh></v>
</v>
<v t="karstenw.20201006211549.1"><vh>@clean examples/Example collage 1a-1920x1080.py</vh>
<v t="karstenw.20201006211616.1"><vh>Declarations</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="karstenw.20170709210040.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20170709210125.1"># PhotoBot 0.8 beta - last updated for NodeBox 1rc4 
# Author: Tom De Smedt &lt;tomdesmedt@trapdoor.be&gt;
# Manual: http://nodebox.net/code/index.php/PhotoBot
# Copyright (c) 2006 by Tom De Smedt.
# Refer to the "Use" section on http://nodebox.net/code/index.php/Use

from __future__ import print_function

ALL = ['canvas', 'Layers', 'Layer', 'label', 'invertimage', 'cropimage',
    'aspectRatio', 'normalizeOrientationImage', 'insetRect',
    'cropImageToRatioHorizontal', 'scaleLayerToHeight', 'placeImage',
    'resizeImage', 'hashFromString', 'makeunicode', 'datestring', 'filelist',
    'imagefiles', 'imagewells', 'loadImageWell' ]

import sys
import os
import types
FloatType = types.FloatType
StringType = types.StringType

import math
sqrt = math.sqrt
pow = math.pow
sin = math.sin
cos = math.cos
degrees = math.degrees
radians = math.radians
asin = math.asin

import fractions
Fraction = fractions.Fraction

import datetime
import time
import hashlib
import unicodedata

import colorsys

import PIL
import PIL.ImageFilter as ImageFilter
import PIL.Image as Image
import PIL.ImageChops as ImageChops
import PIL.ImageEnhance as ImageEnhance
import PIL.ImageOps as ImageOps
import PIL.ImageDraw as ImageDraw
import PIL.ImageStat as ImageStat
import PIL.ImageFont as ImageFont

# disable large image warning
old = Image.MAX_IMAGE_PIXELS
Image.MAX_IMAGE_PIXELS = None # 200000000
# print( "MAX_IMAGE_PIXELS: %i" % old)


import pdb
import pprint
pp = pprint.pprint
kwdbg = 0
import traceback

</t>
<t tx="karstenw.20170709210125.10">def gradient(self, style=LINEAR, w=1.0, h=1.0, name="",
                   radius=0, radius2=0):

    """Creates a gradient layer.

    Creates a gradient layer, that is usually used together
    with the mask() function.

    All the image functions work on gradients, so they can
    easily be flipped, rotated, scaled, inverted, made brighter
    or darker, ...

    Styles for gradients are LINEAR, RADIAL, DIAMOND, SINE,
    COSINE and ROUNDRECT
    """

    w0 = self.w
    h0 = self.h
    if type(w) == FloatType:
        w = int(w*w0)
    if type(h) == FloatType:
        h = int(h*h0)

    img = None
    if style in (SOLID, LINEAR, RADIAL, DIAMOND,
                 SINE, COSINE, RADIALCOSINE):
        img = self.makegradientimage(style, w, h)
        img = img.convert("RGBA")
        return self.layer(img, 0, 0, name=name)

    if style == QUAD:
        # make a rectangle with softened edges
        result = Image.new("L", (int(w),int(h)), 255)
        
        mask = Image.new("L", (w,h), 255)
        draw = ImageDraw.Draw(mask)

        if radius == 0 and radius2 == 0:
            radius = w / 4.0
            radius2 = w / 10.0

        r1 = int(round(radius,0))
        r2 = int(round(radius2,0))
        
        if r1 == 0:
            r1 = 1
        if r2 == 0:
            r2 = 1
        d1 = 2 * r1
        d2 = 2 * r2

        # create the base rect
        baserect = self.makegradientimage(SOLID, w-d1, h-d2)
        
        # create the vertical gradients
        verleft = self.makegradientimage(COSINE, r1, h)
        verleft = verleft.transpose(Image.FLIP_LEFT_RIGHT)
        vertright = verleft.rotate( 180 )

        # create the horizontal gradients
        # since LINEAR goes from left to right, 
        horup = self.makegradientimage(COSINE, r2, w)
        horup = horup.transpose(Image.FLIP_LEFT_RIGHT)
        hordown = horup.rotate( -90, expand=1 )
        horup = hordown.rotate( 180 )

        # assemble
        result.paste( baserect, box=( r1,   0) )
        result.paste( verleft,  box=( 0,    0) )
        result.paste( vertright,box=( w-r1, 0) )

        mask.paste( hordown,    box=( 0,    0) )
        mask.paste( horup,      box=( 0,    h-r2) )

        result = ImageChops.darker(result, mask)
        result = result.convert("RGBA")
        del mask, horup, hordown
        del baserect, verleft, vertright
        return self.layer(result, 0, 0, name=name)

    if style == ROUNDRECT:
        result = Image.new("L", (int(w),int(h)), 255)
        r1 = int(round(radius))
        r2 = int(round(radius2))
        if r1 == 0:
            r1 = 1
        if r2 == 0:
            r2 = 1
        d1 = 2 * r1
        d2 = 2 * r2

        # take 1 radial grad for the 4 corners
        corners = self.makegradientimage(RADIALCOSINE, d1, d2)

        # top left
        b = corners.copy()
        tl = b.crop( box=(0,0,r1,r2) )

        # top right
        b = corners.copy()
        tr = b.crop( box=(r1,0,d1,r2) )

        # bottom left
        b = corners.copy()
        bl = b.crop( box=(0,r2,r1,d2) )

        # bottom right
        b = corners.copy()
        br = b.crop( box=(r1,r2,d1,d2) )

        # create the base rect
        brw = w - d1
        brh = h - d2
        baserect = self.makegradientimage(SOLID, brw, brh)
        
        # create the vertical gradients
        verleft = self.makegradientimage(COSINE, r1, brh)
        verleft = verleft.transpose(Image.FLIP_LEFT_RIGHT)
        vertright = verleft.rotate( 180 )

        # create the horizontal gradients
        # since LINEAR goes from left to right, 
        horup = self.makegradientimage(COSINE, r2, brw)
        horup = horup.transpose(Image.FLIP_LEFT_RIGHT)
        hordown = horup.rotate( -90, expand=1 )
        horup = hordown.rotate( 180 )

        # assemble
        result.paste( baserect, box=( r1,     r2) )

        result.paste( hordown,  box=( r1,     0) )
        result.paste( horup,    box=( r1,     brh+r2) )

        result.paste( verleft,  box=( 0,     r2) )
        result.paste( vertright,box=( brw+r1, r2) )

        result.paste( tl,       box=( 0,     0) )
        result.paste( tr,       box=( brw+r1, 0) )
        result.paste( bl,       box=( 0,     brh+r2) )
        result.paste( br,       box=( brw+r1, brh+r2) )
        img = result.convert("RGBA")
        del corners, tl, tr, bl, br, b
        del horup, hordown
        del baserect
        del verleft, vertright
        return self.layer(img, 0, 0, name=name)

</t>
<t tx="karstenw.20170709210125.11">def merge(self, layers):
    
    """Flattens the given layers on the canvas.
    
    Merges the given layers with the indices in the list
    on the bottom layer in the list.
    The other layers are discarded.
    
    """
    
    layers.sort()
    if layers[0] == 0:
        del layers[0]
    self.flatten(layers)

</t>
<t tx="karstenw.20170709210125.12">def flatten(self, layers=[]):

    """Flattens all layers according to their blend modes.

    Merges all layers to the canvas,
    using the blend mode and opacity defined for each layer.
    Once flattened, the stack of layers is emptied except
    for the transparent background (bottom layer).

    """
    
    # When the layers argument is omitted,
    # flattens all the layers on the canvas.
    # When given, merges the indexed layers.
    
    # Layers that fall outside of the canvas are cropped:
    # this should be fixed by merging to a transparent background
    # large enough to hold all the given layers' data
    # (=time consuming).
    
    if layers == []:
        layers = range(1, len(self.layers))
    background = self.layers._get_bg()
    background.name = "Background"
    
    for i in layers:
        layer = self.layers[i]
    
        # Determine which portion of the canvas
        # needs to be updated with the overlaying layer.
    
        x = max(0, layer.x)
        y = max(0, layer.y)
        w = min(background.w, layer.x+layer.w)
        h = min(background.h, layer.y+layer.h)
    
        base = background.img.crop((x, y, w, h))

        # Determine which piece of the layer
        # falls within the canvas.

        x = max(0, -layer.x)
        y = max(0, -layer.y)
        w -= layer.x
        h -= layer.y

        blend = layer.img.crop((x, y, w, h))
        lblend = blend.convert("L")
        bwblend = lblend.convert("1")
        # Buffer layer blend modes:
        # the base below is a flattened version
        # of all the layers below this one,
        # on which to merge this blended layer.
    
        if layer.blend == NORMAL:
            buffer = blend
        elif layer.blend == MULTIPLY:
            buffer = ImageChops.multiply(base, blend)
        elif layer.blend == SCREEN:
            buffer = ImageChops.screen(base, blend)
        elif layer.blend == OVERLAY:
            buffer = Blend().overlay(base, blend)
        elif layer.blend == HUE:
            buffer = Blend().hue(base, blend)
        elif layer.blend == COLOR:
            buffer = Blend().color(base, blend)
        elif layer.blend == ADD:
            buffer = ImageChops.add(base, blend)

        elif layer.blend == SUBTRACT:
            img1 = base.convert("RGB")
            img2 = blend.convert("RGB")
            buffer = ImageChops.subtract_modulo(img1, img2)
            buffer = buffer.convert("RGBA")
            del img1, img2
            # buffer = ImageChops.subtract(base, blend)
            # buffer = Blend().subtract(base, blend)
        elif layer.blend == ADD_MODULO:
            buffer = ImageChops.add_modulo(base, blend)
        elif layer.blend == SUBTRACT_MODULO:
            buffer = Blend().subtract_modulo(base, blend)



        elif layer.blend == DIFFERENCE:
            # buffer = ImageChops.difference(base, blend)
            img1 = base.convert("RGB")
            img2 = blend.convert("RGB")
            buffer = ImageChops.difference(img1, img2)
            buffer = buffer.convert("RGBA")
            del img1, img2
        
        # Buffer a merge between the base and blend
        # according to the blend's alpha channel:
        # the base shines through where the blend is less opaque.
    
        # Merging the first layer to the transparent canvas
        # works slightly different than the other layers.

        # alpha = buffer.split()[3]
        alpha = buffer.getchannel("A")
        basealpha = base.getchannel("A")
        if i == 1:
            buffer = Image.composite(base, buffer, basealpha) #base.split()[3])
        else:
            buffer = Image.composite(buffer, base, alpha)
    
        # The alpha channel becomes a composite of this layer and the base:
        # the base's (optional) tranparent background
        # is retained in arrays where the blend layer
        # is transparent as well.
    
        alpha = ImageChops.lighter(alpha, basealpha) #base.split()[3])
        buffer.putalpha(alpha)
    
        # Apply the layer's opacity,
        # merging the buffer to the base with
        # the given layer opacity.
    
        base = Image.blend(base, buffer, layer.alpha)

        # Merge the base to the flattened canvas.

        x = max(0, int(layer.x))
        y = max(0, int(layer.y))
        background.img.paste(base, (x,y))
        del base, buffer, alpha, blend

    layers.reverse()
    for i in layers:
        del self.layers[i].img
        del self.layers[i]

    img = Image.new("RGBA", (self.w,self.h), (255,255,255,0))
    self.layers._set_bg(Layer(self, img, 0, 0, name="_bg"))
    
    if len(self.layers) == 1:
        self.layers.append(background)
    else:
        self.layers.insert(layers[-1], background)

</t>
<t tx="karstenw.20170709210125.13">def export(self, name, ext=".png", format="PNG"):

    """Exports the flattened canvas.

    Flattens the canvas.
    PNG retains the alpha channel information.
    Other possibilities are JPEG and GIF.

    """

    # pdb.set_trace()
    
    &lt;&lt;init&gt;&gt;
    if kwdbg:
        &lt;&lt;debug&gt;&gt;

    self.flatten()
    self.layers[1].img.save(path, format=format, optimize=False)
    if kwdbg:
        print( "export() %s" % path.encode("utf-8") )
    return path

</t>
<t tx="karstenw.20170709210125.14">def draw(self, x=0, y=0, name="", ext=".png", format='PNG'):
    
    """Places the flattened canvas in NodeBox.
    
    Exports to a temporary PNG file.
    # Draws the PNG in NodeBox using the image() command.
    # Removes the temporary file.
    
    """
    #if not name:
    #    name = "photobot_" + datestring()
    #if not ext:
    #    ext = ".png"

    #folder = os.path.abspath( os.curdir )
    #folder = os.path.join( folder, "exports" )
    #if not os.path.exists( folder ):
    #    try:
    #        os.makedirs( folder )
    #    except:
    #        pass
    try:
        #filename = os.path.join( folder, name + ext )
        #filename = os.path.abspath(filename)
        # path = self.export(filename)
        path = self.export(name, ext, format)
        try:
            #if nodeboxlib:
            _ctx.image(path, x, y)
        except NameError,err:
            pass
        if 0:
            os.unlink( path )
        return path
    except Exception, err:
        print(err)
        print()
        exc_type, exc_value, exc_tb = sys.exc_info()
        traceback.print_exception(exc_type, exc_value, exc_tb)
        print()

</t>
<t tx="karstenw.20170709210125.15">def preferences(interpolation=INTERPOLATION):

    """Settings that influence image manipulation.

    Currently, only defines the image interpolation, which
    can be set to NEAREST, BICUBIC, BILINEAR or LANCZOS.

    """
    self.interpolation = interpolation

</t>
<t tx="karstenw.20170709210125.16">def canvas(w, h):
    return Canvas(w, h)


</t>
<t tx="karstenw.20170709210125.17">class Layers(list):
    
    """Extends the canvas.layers[] list so it indexes layers names.
    
    When the index is an integer, returns the layer at that  index.
    When the index is a string, returns the first layer with that name.
    
    The first element, canvas.layers[0],
    is the transparent background and must remain untouched.
    
    """
    
    @others
</t>
<t tx="karstenw.20170709210125.18">def __getitem__(self, index):

    if type(index) in (int, long):
        return list.__getitem__(self, index)

    elif type(index) in (str, unicode):
        for layer in self:
            if layer.name == index:
                return layer
    return None

</t>
<t tx="karstenw.20170709210125.19">def _get_bg(self):
    
    return list.__getitem__(self, 0)
    
</t>
<t tx="karstenw.20170709210125.20">def _set_bg(self, layer):
    
    list.__setitem__(self, 0, layer)


</t>
<t tx="karstenw.20170709210125.21">class Layer:
    
    """Implements a layer on the canvas.
    
    A canvas layer stores an image at a given position on the canvas,
    and all the Photoshop transformations possible for this layer:
    duplicate(), desature(), overlay(), rotate(), and so on.
    
    """
    
    @others
</t>
<t tx="karstenw.20170709210125.22">def __init__(self, canvas, img, x=0, y=0, name=""):
    
    self.canvas = canvas
    self.name = name
    self.img = img
    self.x = x
    self.y = y
    self.w = img.size[0]
    self.h = img.size[1]
    self.alpha = 1.0
    self.blend = NORMAL
    self.pixels = Pixels(self.img, self)
    
</t>
<t tx="karstenw.20170709210125.23">def prnt(self):
    # for debugging
    print("-" * 20)
    print( "name: '%s' " % self.name.encode("utf-8") )
    print("xy: %i  %i" % (self.x, self.y) )
    print("wh: %i  %i" % (self.w, self.h) )
    print("alpha: %.2f" % self.alpha)
    print("blend: %.2f" % self.blend)
    print("-" * 20)

</t>
<t tx="karstenw.20170709210125.24">def index(self):
    
    """Returns this layer's index in the canvas.layers[].
    
    Searches the position of this layer in the canvas'
    layers list, return None when not found.
    
    """
    
    for i in range(len(self.canvas.layers)):
        if self.canvas.layers[i] == self:
            break
    if self.canvas.layers[i] == self:
        return i
    else:
        return None

</t>
<t tx="karstenw.20170709210125.25">def copy(self):
    
    """Returns a copy of the layer.
    
    This is different from the duplicate() method,
    which duplicates the layer as a new layer on the canvas.
    The copy() method returns a copy of the layer
    that can be added to a different canvas.
    
    """
    
    layer = Layer(None, self.img.copy(), self.x, self.y, self.name)
    layer.w = self.w
    layer.h = self.h
    layer.alpha = self.alpha
    layer.blend = self.blend
    
    return layer
    
</t>
<t tx="karstenw.20170709210125.26">def delete(self):
    
    """Removes this layer from the canvas.
          
    """
    
    i = self.index()
    if i != None:
        del self.canvas.layers[i]
    
</t>
<t tx="karstenw.20170709210125.27">def up(self):
    
    """Moves the layer up in the stacking order.
    
    """
    
    i = self.index()
    if i != None:
        del self.canvas.layers[i]
        i = min(len(self.canvas.layers), i+1)
        self.canvas.layers.insert(i, self)
        
</t>
<t tx="karstenw.20170709210125.28">def down(self):
    
    """Moves the layer down in the stacking order.
    
    """
    
    i = self.index()
    if i != None:
        del self.canvas.layers[i]
        i = max(0, i-1)
        self.canvas.layers.insert(i, self)

</t>
<t tx="karstenw.20170709210125.29">def bounds(self):

    """Returns the size of the layer.

    This is the width and height of the bounding box,
    the invisible rectangle around the layer.

    """

    return self.img.size

</t>
<t tx="karstenw.20170709210125.30">def select(self, path, feather=True):

    """Applies the polygonal lasso tool on a layer.

    The path paramater is a list of points,
    either [x1, y1, x2, y2, x3, y3, ...]
    or [(x1,y1), (x2,y2), (x3,y3), ...]

    The parts of the layer that fall outside
    this polygonal area are cut.
    
    The selection is not anti-aliased,
    but the feather parameter creates soft edges.

    """

    w, h = self.img.size
    mask = Image.new("L", (w,h), 0)
    draw = ImageDraw.Draw(mask)
    
    draw = ImageDraw.Draw(mask)
    draw.polygon(path, fill=255)

    if feather:
        mask = mask.filter(ImageFilter.SMOOTH_MORE)
        mask = mask.filter(ImageFilter.SMOOTH_MORE)
    
    
    mask = ImageChops.darker(mask, self.img.getchannel("A")) #self.img.split()[3])
    self.img.putalpha(mask)

</t>
<t tx="karstenw.20170709210125.31">def mask(self):

    """Masks the layer below with this layer.

    Commits the current layer to the alpha channel of 
    the previous layer. Primarily, mask() is useful when 
    using gradient layers as masks on images below. 

    For example:
    canvas.layer("image.jpg")
    canvas.gradient()
    canvas.layer(2).flip()
    canvas.layer(2).mask()

    Adds a white-to-black linear gradient to
    the alpha channel of image.jpg, 
    making it evolve from opaque on 
    the left to transparent on the right.

    """

    if len(self.canvas.layers) &lt; 2:
        return
    i = self.index()
    if i == 0:
        return
    
    layer = self.canvas.layers[i-1]

    alpha = Image.new("L", layer.img.size, 0)

    #Make a composite of the mask layer in grayscale
    #and its own alpha channel.

    mask = self.canvas.layers[i]        
    flat = ImageChops.darker(mask.img.convert("L"), mask.img.getchannel("A")) #mask.img.split()[3])
    alpha.paste(flat, (mask.x,mask.y))
    alpha = ImageChops.darker(alpha, layer.img.getchannel("A")) #layer.img.split()[3])
    layer.img.putalpha(alpha)

    self.delete()

</t>
<t tx="karstenw.20170709210125.32">def duplicate(self):

    """Creates a copy of the current layer.

    This copy becomes the top layer on the canvas.

    """

    i = self.canvas.layer(self.img.copy(), self.x, self.y, self.name)
    clone = self.canvas.layers[i]
    clone.alpha = self.alpha
    clone.blend = self.blend
                
</t>
<t tx="karstenw.20170709210125.33">def opacity(self, a=100):
    self.alpha = a * 0.01

</t>
<t tx="karstenw.20170709210125.34">def multiply(self):
    self.blend = MULTIPLY

</t>
<t tx="karstenw.20170709210125.35">def screen(self):
    self.blend = SCREEN

</t>
<t tx="karstenw.20170709210125.36">def overlay(self):
    self.blend = OVERLAY
    
</t>
<t tx="karstenw.20170709210125.37">def hue(self):
    self.blend = HUE
    
</t>
<t tx="karstenw.20170709210125.38">def color(self):
    self.blend = COLOR
    
</t>
<t tx="karstenw.20170709210125.39">def brightness(self, value=1.0):

    """Increases or decreases the brightness in the layer.

    The given value is a percentage to increase
    or decrease the image brightness,
    for example 0.8 means brightness at 80%.

    """
    if value &gt; 5:
        value = value * 0.01
    b = ImageEnhance.Brightness(self.img) 
    self.img = b.enhance(value)

</t>
<t tx="karstenw.20170709210125.40">def contrast(self, value=1.0):

    """Increases or decreases the contrast in the layer.

    The given value is a percentage to increase
    or decrease the image contrast,
    for example 1.2 means contrast at 120%.

    """
    # this crashes sometimes
    try:
        if value &gt; 5:
            value = value * 0.01
        c = ImageEnhance.Contrast(self.img) 
        self.img = c.enhance(value)
    except:
        pass

</t>
<t tx="karstenw.20170709210125.41">def desaturate(self):

    """Desaturates the layer, making it grayscale.

    Instantly removes all color information from the layer,
    while maintaing its alpha channel.

    """

    # alpha = self.img.split()[3]
    alpha = self.img.getchannel("A")
    self.img = self.img.convert("L")
    self.img = self.img.convert("RGBA")
    self.img.putalpha(alpha)

</t>
<t tx="karstenw.20170709210125.42">
def colorize(self, black, white, mid=None,
                   blackpoint=0, whitepoint=255, midpoint=127):

    """Use the ImageOps.colorize() on desaturated layer.
    
    """
    # 
    # alpha = self.img.split()[3]
    alpha = self.img.getchannel("A")
    img = self.img.convert("L")
    img = ImageOps.colorize(img, black, white, mid,
                                 blackpoint=0, whitepoint=255, midpoint=127)
    img = img.convert("RGBA")
    img.putalpha(alpha)
    self.img = img

def posterize(self, bits=8):
    if 0: #not (1 &lt;= bits &lt;= 8):
        return
    # alpha = self.img.split()[3]
    alpha = self.img.getchannel("A")
    img = self.img.convert("RGB")
    img = ImageOps.posterize(img, bits)
    img = img.convert("RGBA")
    img.putalpha(alpha)
    self.img = img

def solarize(self, threshhold):
    # alpha = self.img.split()[3]
    alpha = self.img.getchannel("A")
    img = self.img.convert("RGB")
    img = ImageOps.solarize(img, threshhold)
    img = img.convert("RGBA")
    img.putalpha(alpha)
    self.img = img

def autocontrast(self, cutoff=0, ignore=None):
    if 0: #not (1 &lt;= bits &lt;= 8):
        return
    # alpha = self.img.split()[3]
    alpha = self.img.getchannel("A")
    img = self.img.convert("RGB")
    img = ImageOps.autocontrast(img, cutoff, ignore)
    img = img.convert("RGBA")
    img.putalpha(alpha)
    self.img = img

def deform( self, deformer, resample=2 ):
    self.img = ImageOps.deform(self.img, deformer, resample)

def equalize(self, mask=None):
    self.img = ImageOps.equalize(self.img, mask)

</t>
<t tx="karstenw.20170709210125.43">def invert(self):

    """Inverts the layer.

    """
    self.img = invertimage( self.img )

</t>
<t tx="karstenw.20170709210125.44">def translate(self, x, y):

    """Positions the layer at the given coordinates.

    The x and y parameters define where to position 
    the top left corner of the layer,
    measured from the top left of the canvas.

    """

    self.x = int( round( x ))
    self.y = int( round( y ))

</t>
<t tx="karstenw.20170709210125.45">def scale(self, w=1.0, h=1.0):

    """Resizes the layer to the given width and height.

    When width w or height h is a floating-point number,
    scales percentual, 
    otherwise scales to the given size in pixels.

    """
    w0, h0 = self.img.size
    if type(w) == FloatType:
        w = int(w*w0)
    if type(h) == FloatType:
        h = int(h*h0)
    self.img = self.img.resize((w,h), resample=LANCZOS)
    self.w = w
    self.h = h

</t>
<t tx="karstenw.20170709210125.46">def distort(self, x1=0,y1=0, x2=0,y2=0, x3=0,y3=0, x4=0,y4=0):

    """Distorts the layer.
    
    Distorts the layer by translating 
    the four corners of its bounding box to the given coordinates:
    upper left (x1,y1), upper right(x2,y2),
    lower right (x3,y3) and lower left (x4,y4).
    
    """

    w, h = self.img.size
    quad = (-x1,-y1, -x4,h-y4, w-x3,w-y3, w-x2,-y2)
    # quad = (x1,y1, x2,y2, x3,y3, x4,y4) #, LANCZOS)
    self.img = self.img.transform(self.img.size, Image.QUAD, quad)

</t>
<t tx="karstenw.20170709210125.47">def rotate(self, angle):

    """Rotates the layer.

    Rotates the layer by given angle.
    Positive numbers rotate counter-clockwise,
    negative numbers rotate clockwise.

    Rotate commands are executed instantly,
    so many subsequent rotates will distort the image.

    """

    # When a layer rotates, its corners will fall
    # outside of its defined width and height.
    # Thus, its bounding box needs to be expanded.

    # Calculate the diagonal width, and angle from
    # the layer center.  This way we can use the
    # layers's corners to calculate the bounding box.

    w0, h0 = self.img.size
    d = sqrt(pow(w0,2) + pow(h0,2))
    d_angle = degrees(asin((w0*0.5) / (d*0.5)))

    angle = angle % 360
    if (    angle &gt;   90
        and angle &lt;= 270):
        d_angle += 180

    w = sin(radians(d_angle + angle)) * d
    w = max(w, sin(radians(d_angle - angle)) * d)
    w = int(abs(w))

    h = cos(radians(d_angle + angle)) * d
    h = max(h, cos(radians(d_angle - angle)) * d)
    h = int(abs(h))

    dx = int((w-w0) / 2)
    dy = int((h-h0) / 2)
    d = int(d)

    # The rotation box's background color
    # is the mean pixel value of the rotating image.
    # This is the best option to avoid borders around
    # the rotated image.

    bg = ImageStat.Stat(self.img).mean
    bg = (int(bg[0]), int(bg[1]), int(bg[2]), 0)

    box = Image.new("RGBA", (d,d), bg)
    box.paste(self.img, ((d-w0)/2, (d-h0)/2))
    box = box.rotate(angle, Image.BICUBIC)
    box = box.crop(((d-w)/2+2, (d-h)/2, d-(d-w)/2, d-(d-h)/2))
    self.img = box

    # Since rotate changes the bounding box size,
    # update the layers' width, height, and position,
    # so it rotates from the center.

    self.x += (self.w-w)/2
    self.y += (self.h-h)/2
    self.w = w
    self.h = h   

</t>
<t tx="karstenw.20170709210125.48">def flip(self, axis=HORIZONTAL):

    """Flips the layer, either HORIZONTAL or VERTICAL.

    """

    if axis &amp; HORIZONTAL:
        self.img = self.img.transpose(Image.FLIP_LEFT_RIGHT)
    if axis &amp; VERTICAL:
        self.img = self.img.transpose(Image.FLIP_TOP_BOTTOM)

</t>
<t tx="karstenw.20170709210125.49">def blur(self):
    
    """Blurs the layer.
    
    """

    self.img = self.img.filter(ImageFilter.BLUR)

</t>
<t tx="karstenw.20170709210125.5">class Canvas:
    
    """Implements a canvas with layers.
    
    A canvas is an empty Photoshop document,
    where layers can be placed and manipulated.
    """

    @others
</t>
<t tx="karstenw.20170709210125.50">def sharpen(self, value=1.0):

    """Increases or decreases the sharpness in the layer.

    The given value is a percentage to increase
    or decrease the image sharpness,
    for example 0.8 means sharpness at 80%.

    """
 
    s = ImageEnhance.Sharpness(self.img) 
    self.img = s.enhance(value)
    
</t>
<t tx="karstenw.20170709210125.51">def statistics(self):
    
    alpha = self.img.getchannel("A")
    return ImageStat.Stat(self.img, alpha) #self.img.split()[3])
    
</t>
<t tx="karstenw.20170709210125.52">def levels(self):
    
    """Returns a histogram for each RGBA channel.
    
    Returns a 4-tuple of lists, r, g, b, and a.
    Each list has 255 items, a count for each pixel value.
            
    """
    
    h = self.img.histogram()
    r = h[0:255]
    g = h[256:511]
    b = h[512:767]
    a = h[768:1024]
    
    return r, g, b, a

</t>
<t tx="karstenw.20170709210125.53">class Blend:
    
    """Layer blending modes.
    
    Implements additional blending modes to those present in PIL.
    These blending functions can not be used separately from
    the canvas.flatten() method, where the alpha compositing
    of two layers is handled.
    
    Since these blending are not part of a C library,
    but pure Python, they take forever to process.
    
    """
    
    def subtract(self, img1, img2, scale=1.0, offset=0):
        base = img1.convert("RGB")
        blend = img2.convert("RGB")
        result = ImageChops.subtract(base, blend, scale=scale, offset=offset)
        result = result.convert("RGBA")
        return result

    def subtract_modulo(self, img1, img2):
        base = img1.convert("RGB")
        blend = img2.convert("RGB")
        result = ImageChops.subtract_modulo(base, blend)
        result = result.convert("RGBA")
        return result

    @others
</t>
<t tx="karstenw.20170709210125.54">def overlay(self, img1, img2):

    """Applies the overlay blend mode.

    Overlays image img2 on image img1.
    The overlay pixel combines multiply and screen:
    it multiplies dark pixels values and screen light values.
    Returns a composite image with the alpha channel retained.

    """

    p1 = list(img1.getdata())
    p2 = list(img2.getdata())

    for i in range(len(p1)):
    
        p3 = ()
        for j in range(len(p1[i])):

            a = p1[i][j] / 255.0
            b = p2[i][j] / 255.0
        
            # When overlaying the alpha channels,
            # take the alpha of the most transparent layer.
        
            if j == 3:
                # d = (a+b)*0.5
                # d = a
                d = min(a,b)
            elif a &gt; 0.5:
                d = 2*(a+b-a*b)-1
            else:
                d = 2*a*b            
            p3 += (int(d*255),)
    
        p1[i] = p3
    
    img = Image.new("RGBA", img1.size, 255)
    img.putdata(p1)
    return img

</t>
<t tx="karstenw.20170709210125.55">def hue(self, img1, img2):

    """Applies the hue blend mode.

    Hues image img1 with image img2.
    The hue filter replaces the hues of pixels in img1
    with the hues of pixels in img2.
    Returns a composite image with the alpha channel retained.

    """

    p1 = list(img1.getdata())
    p2 = list(img2.getdata())
    for i in range(len(p1)):
    
        r1, g1, b1, a1 = p1[i]
        r1 = r1 / 255.0
        g1 = g1 / 255.0
        b1 = b1 / 255.0
    
        h1, s1, v1 = colorsys.rgb_to_hsv(r1, g1, b1)
    
        r2, g2, b2, a2 = p2[i]
        r2 = r2 / 255.0
        g2 = g2 / 255.0
        b2 = b2 / 255.0
        h2, s2, v2 = colorsys.rgb_to_hsv(r2, g2, b2)
    
        r3, g3, b3 = colorsys.hsv_to_rgb(h2, s1, v1)
    
        r3 = int(r3*255)
        g3 = int(g3*255)
        b3 = int(b3*255)
        p1[i] = (r3, g3, b3, a1)

    img = Image.new("RGBA", img1.size, 255)
    img.putdata(p1)
    return img

</t>
<t tx="karstenw.20170709210125.56">def color(self, img1, img2):

    """Applies the color blend mode.

    Colorize image img1 with image img2.
    The color filter replaces the hue and saturation of pixels in img1
    with the hue and saturation of pixels in img2.
    Returns a composite image with the alpha channel retained.

    """
    p1 = list(img1.getdata())
    p2 = list(img2.getdata())
    for i in range(len(p1)):
    
        r1, g1, b1, a1 = p1[i]
        r1 = r1 / 255.0
        g1 = g1 / 255.0
        b1 = b1 / 255.0
    
        h1, s1, v1 = colorsys.rgb_to_hsv(r1, g1, b1)
    
        r2, g2, b2, a2 = p2[i]
        r2 = r2 / 255.0
        g2 = g2 / 255.0
        b2 = b2 / 255.0
        h2, s2, v2 = colorsys.rgb_to_hsv(r2, g2, b2)
    
        r3, g3, b3 = colorsys.hsv_to_rgb(h2, s2, v1)
    
        r3 = int(r3*255)
        g3 = int(g3*255)
        b3 = int(b3*255)
        p1[i] = (r3, g3, b3, a1)

    img = Image.new("RGBA", img1.size, 255)
    img.putdata(p1)
    return img

</t>
<t tx="karstenw.20170709210125.57">class Pixels:
    
    """Provides direct access to a layer's pixels.
    
    The layer.pixels[] contains all pixel values
    in a 1-dimensional array.
    Each pixel is a tuple containing (r,g,b,a) values.
    
    After the array has been updated, layer.pixels.update()
    must be called for the changes to commit.
    
    """
    
    @others
</t>
<t tx="karstenw.20170709210125.58">def __init__(self, img, layer):
    
    self.layer = layer
    self.img = img
    self.data = None
    
</t>
<t tx="karstenw.20170709210125.59">def __getitem__(self, i):

    w, h = self.img.size
    noofpixels = w * h
    if i &gt;= noofpixels:
        i -= noofpixels
    if i &lt; 0:
        i += noofpixels
    
    if self.data == None:
        self.data = list(self.img.getdata())
    return self.data[i]
    
</t>
<t tx="karstenw.20170709210125.6">def __init__(self, w, h):
    
    """Creates a new canvas.

    Creates the working area on which to blend layers.
    The canvas background is transparent,
    but a background color could be set using the fill() function.
    """
    
    self.interpolation = INTERPOLATION
    self.layers = Layers()
    self.w = w
    self.h = h
    img = Image.new("RGBA", (w,h), (255,255,255,0))
    self.layer(img, name="_bg")

</t>
<t tx="karstenw.20170709210125.60">def __setitem__(self, i, rgba):
    
    w, h = self.img.size
    noofpixels = w * h
    if i &gt;= noofpixels:
        i -= noofpixels
    if i &lt; 0:
        i += noofpixels
    
    if self.data == None:
        self.data = list(self.img.getdata())
    self.data[i] = rgba

</t>
<t tx="karstenw.20170709210125.61">def __iter__(self):
    
    for i in xrange(len(self)):
        yield self[i]

</t>
<t tx="karstenw.20170709210125.62">def __len__(self):
    
    w, h = self.img.size
    return w * h
                
</t>
<t tx="karstenw.20170709210125.63">def update(self):
    
    if self.data != None:
        self.img.putdata(self.data)
        self.data = None
    
</t>
<t tx="karstenw.20170709210125.64">def convolute(self, kernel, scale=None, offset=0):
    
    """A (3,3) or (5,5) convolution kernel.
    
    The kernel argument is a list with either 9 or 25 elements,
    the weight for each surrounding pixels to convolute.
    
    """
    
    if len(kernel)   ==  9: size = (3,3)
    elif len(kernel) == 25: size = (5,5)
    else:                   return
    
    if scale == None:
        scale = 0
        for x in kernel:
            scale += x
        if scale == 0:
            scale = 1
 
    # f = ImageFilter.BuiltinFilter()
    # f.filterargs = size, scale, offset, kernel
    f = ImageFilter.Kernel(size, kernel, scale=scale, offset=offset)
    self.layer.img = self.layer.img.filter(f)

</t>
<t tx="karstenw.20170709210125.65">def aspectRatio(size, maxsize, height=False, width=False, assize=False):
    """Resize size=(w,h) to maxsize.
    use height == maxsize if height==True
    use width == maxsize if width==True
    use max(width,height) == maxsize if width==height==False
    
    """
    w, h = size
    scale = 1.0
    
    if width !=False:
        currmax = w
    elif height !=False:
        currmax = h
    else:
        currmax = max( (w,h) )
    if width and height:
        currmax = min( (w,h) )
    if currmax == maxsize:
        # return 1.0
        pass
    elif maxsize == 0:
        #return 1.0
        pass
    else:
        scale = float(maxsize) / currmax
        w = int( round( w*scale, 0) )
        h = int( round( h*scale, 0) )
        size = (w,h)
    if assize:
        return size
    return scale


</t>
<t tx="karstenw.20170709210125.66">def normalizeOrientationImage( img ):
    """Rotate an image according to exif info.
    
    """
    rotation = 0
    try:
        info = img._getexif()
        if 274 in info:
            r = info[274]
            if r == 3:
                rotation = 180
            elif r == 6:
                rotation = -90
            elif r == 8:    
                rotation = 90
    except (Exception, IndexError), err:
        pass
    if rotation != 0:
        return img.rotate( rotation )
    return img


</t>
<t tx="karstenw.20170709210125.67">def imagewells():
    """Find a file named "imagewell.txt" and interpret it as image folder paths.
    If no file is found create one with the desktop image folders for
    mac &amp; win10.
    
    """
    folders = ["/Library/Desktop Pictures", "C:\Windows\Web" ]
    images = os.path.abspath( "images" )
    if os.path.exists( images ):
        folders.append( images )
    fullpath = os.path.abspath( "imagewell.txt" )
    
    if not os.path.exists( fullpath ):
        try:
            f = open(fullpath, 'w')
            f.write( "\n".join( folders ) )
            f.close()
        except:
            pass
        return folders
    try:
        with open(fullpath, 'Ur') as f:
            lines = f.readlines()
        if not lines:
            return folders
        folders = []
        for line in lines:
            line = line.strip("\n\r")
            folders.append( makeunicode( line ) )
    except:
        pass
    folders = [x for x in folders if os.path.exists(x)]
    return folders

</t>
<t tx="karstenw.20170709210125.7">def layer(self, img, x=0, y=0, name=""):

    """Creates a new layer from file, Layer, PIL Image.

    If img is an image file or PIL Image object,
    Creates a new layer with the given image file.
    The image is positioned on the canvas at x, y.
    
    If img is a Layer,
    uses that layer's x and y position and name.
    """

    if isinstance(img, Image.Image):
        img = img.convert("RGBA")
        self.layers.append(Layer(self, img, x, y, name))
        return len(self.layers) - 1

    if isinstance(img, Layer):
        img.canvas = self
        self.layers.append(img)
        return len(self.layers) - 1

    if type(img) in (str, unicode):
        try:
            img = Image.open(img)
            img = img.convert("RGBA")
            self.layers.append(Layer(self, img, x, y, name))
            return len(self.layers) - 1
        except Exception, err:
            print( "Canvas.layer( %s ) FAILED." %repr( img ) )
            print(err)
            print()
            exc_type, exc_value, exc_tb = sys.exc_info()
            traceback.print_exception(exc_type, exc_value, exc_tb)
            print()
            return None


</t>
<t tx="karstenw.20170709210125.8">def fill(self, rgb, x=0, y=0, w=None, h=None, name=""):

    """Creates a new fill layer.

    Creates a new layer filled with the given rgb color.
    For example, fill((255,0,0)) creates a red fill.
    The layers fills the entire canvas by default.
    """ 

    if w == None:
        w = self.w - x
    if h == None:
        h = self.h - y
    img = Image.new("RGBA", (w,h), rgb)
    return self.layer(img, x, y, name)

</t>
<t tx="karstenw.20170709210125.9">def makegradientimage(self, style, w, h):
    """Creates the actual gradient image.
    
    This has been factored out of gradient() so complex gradients like
    ROUNDRECT which consist of multiple images can be composed.
    """
    w0 = self.w 
    h0 = self.h
    if type(w) == FloatType:
        w *= w0
    if type(h) == FloatType:
        h *= h0
    
    # prevent some div by 0 errors
    if w &lt; 0:
        w = -w
    if h &lt; 0:
        h = -h
    w = max(1,w)
    h = max(1,h)

    if kwdbg:
        print( (style, w0,h0,w,h) )

    if style not in (RADIALCOSINE,):
        img = Image.new("L", (int(w),int(h)), 255)
    else:
        img = Image.new("L", (int(w),int(h)), 0)

    draw = ImageDraw.Draw(img)

    if style == SOLID:
        draw.rectangle((0, 0, w, h), fill=255)

    if style == LINEAR:
        for i in range(int(w)):
            k = 255.0 * i/w
            draw.rectangle((i, 0, i, h), fill=int(k))
        
    if style == RADIAL:
        r = min(w,h)/2
        for i in range(int(r)):
            k = 255 - 255.0 * i/r
            draw.ellipse((w/2-r+i, h/2-r+i,
                          w/2+r-i, h/2+r-i), fill=int(k))
        
    if style == RADIALCOSINE:
        r = max(w,h) / 2.0
        rx = w / 2.0
        ry = h / 2.0
        
        deg = 90
        base = 90 - deg
        deltaxdeg = deg / rx
        deltaydeg = deg / ry
        deltadeg = deg / r

        step = min(deltaxdeg, deltaydeg)
        for i in range(int(r)):
            # k = 255.0 * i/r
            k = 256 * sin( radians( base + i * deltadeg ) )
            ix = i * (rx / r)
            iy = i * (ry / r)
            draw.ellipse((0 + ix, 0 + iy,
                          w - ix, h - iy), fill=int(k))

    if style == DIAMOND:
        r = max(w,h)
        for i in range(int(r)):
            x = int( i*w / r*0.5 )
            y = int( i*h / r*0.5 )
            k = 255.0 * i/r
            draw.rectangle((x, y, w-x, h-y), outline=int(k))
    
    if style in (SINE, COSINE):
        # sin/cos 0...180 left to right
        action = sin
        deg = 180.0
        base = 0
        if style == COSINE:
            action = cos
            deg = 90.0
            base = 90.0 - deg
        deltadeg = deg / w
        for i in range( int(w) ):
            k = 256 * action( radians( base + i * deltadeg ) )
            draw.line( (i,0,i, h), fill=int(k), width=1)
    result = img.convert("RGBA")
    del img
    del draw
    return result

</t>
<t tx="karstenw.20170710142919.1">@property
def top(self):
    """Interface to top layer.
    
    """
    return self.layers[-1]

</t>
<t tx="karstenw.20170727231803.1"></t>
<t tx="karstenw.20170727231827.1"></t>
<t tx="karstenw.20170727232236.1"></t>
<t tx="karstenw.20170727232434.1"></t>
<t tx="karstenw.20170727233343.1">def crop( self, bounds):

    """Crop a pillow image at bounds(left, top, right, bottom)

    """
    w0, h0 = self.img.size
    x, y = self.x, self.y
    left, top, right, bottom = bounds
    left = max(x, left)
    top = max(y, top)
    right = min(right, w0)
    bottom = min(bottom, h0)
    self.img = self.img.crop( (left, top, right, bottom) )
    self.w, self.h = self.img.size

</t>
<t tx="karstenw.20200419182817.1">def add(self):
    self.blend = ADD

</t>
<t tx="karstenw.20200419182824.1">def subtract(self):
    self.blend = SUBTRACT

</t>
<t tx="karstenw.20200419182831.1">def add_modulo(self):
    self.blend = ADD_MODULO

</t>
<t tx="karstenw.20200419182838.1">def subtract_modulo(self):
    self.blend = SUBTRACT_MODULO

</t>
<t tx="karstenw.20200419182844.1">def difference(self):
    self.blend = DIFFERENCE

</t>
<t tx="karstenw.20200419183112.1"># new
def contour(self):
    
    """Contours the layer.
    
    """

    self.img = self.img.filter(ImageFilter.CONTOUR)

</t>
<t tx="karstenw.20200419183129.1"># new
def detail(self):
    
    """Details the layer.
    
    """

    self.img = self.img.filter(ImageFilter.DETAIL)

</t>
<t tx="karstenw.20200419183142.1"># new
def edge_enhance(self):
    
    """Edge enhances the layer.
    
    """

    self.img = self.img.filter(ImageFilter.EDGE_ENHANCE)

</t>
<t tx="karstenw.20200419183156.1"># new
def edge_enhance_more(self):
    
    """Edge enhances more the layer.
    
    """

    self.img = self.img.filter(ImageFilter.EDGE_ENHANCE_MORE)

</t>
<t tx="karstenw.20200419183210.1"># new
def emboss(self):
    
    """Embosses the layer.
    
    """

    self.img = self.img.filter(ImageFilter.EMBOSS)

</t>
<t tx="karstenw.20200419183218.1"># new
def find_edges(self):
    
    """Find edges in the layer.
    
    """

    self.img = self.img.filter(ImageFilter.FIND_EDGES)

</t>
<t tx="karstenw.20200419183225.1"># new
def smooth(self):
    
    """Smoothes the layer.
    
    """

    self.img = self.img.filter(ImageFilter.SMOOTH)

</t>
<t tx="karstenw.20200419183232.1"># new
def smooth_more(self):
    
    """Smoothes the layer more.
    
    """

    self.img = self.img.filter(ImageFilter.SMOOTH_MORE)

</t>
<t tx="karstenw.20200419183424.1">#
# nodebox &amp; standalone pillow tools
#
</t>
<t tx="karstenw.20200419184336.1">def label( canvas, string, x, y, fontsize=18, fontpath="" ):
    """Needs to be written...

    """
    
    # search for a usable font
    systemarials = [
        "C:\Windows\Fonts\arial.ttf",
        "/Library/Fonts/Arial.ttf"]
    
    systemarials.insert(0, fontpath)
    font = False
    for f in systemarials:
        if os.path.exists( f ):
            font = f
            break
    
    if not font:
        return False

    w,h = canvas.w, canvas.h
    mask = Image.new("L", (w, h), 0)
    blatt = Image.new("RGBA", (w, h), (0,0,0,0))

    drawtext = ImageDraw.Draw( blatt )
    drawmask = ImageDraw.Draw( mask )

    # use a bitmap font
    font =  PIL.ImageFont.truetype(font=font, size=fontsize, index=0, encoding='')
    drawtext.text((x, y), string, font=font, fill=(192,192,192,255))
    drawmask.text((x, y), string, font=font, fill=192)
    drawtext.text((x-1, y-1), string, font=font, fill=(0,0,0,255))
    drawmask.text((x-1, y-1), string, font=font, fill=255)
    
    canvas.layer( blatt )
    canvas.layer( mask )
    canvas.top.mask()


</t>
<t tx="karstenw.20200419184424.1">def invertimage( img ):
    # alpha = img.split()[3]
    alpha = img.getchannel("A")
    img = img.convert("RGB")
    img = ImageOps.invert(img)
    img = img.convert("RGBA")
    img.putalpha(alpha)
    return img


</t>
<t tx="karstenw.20200419184433.1">def cropimage( img, bounds):

    """Crop a pillow image at bounds(left, top, right, bottom)
    
    """
    return img.crop( bounds )


</t>
<t tx="karstenw.20200419185026.1">def insetRect( rectangle, horInset, vertInset):
    x, y, w, h = rectangle
    dh = horInset / 2.0
    dv = vertInset / 2.0
    return x+dh, y+dv, w-horInset, h-vertInset


</t>
<t tx="karstenw.20200419185034.1">def cropImageToRatioHorizontal( layer, ratio ):
    w, h = layer.bounds()
    neww = int( round( h*ratio) )
    d = int( neww / 2.0 )
    x,y,w,h = insetRect( (0,0,w,h), d, 0 )
    layer.img = layer.img.crop(box=(x,y,x+w,y+h))
    return layer


</t>
<t tx="karstenw.20200419185042.1">def scaleLayerToHeight( layer, newheight ):
    # get current image bounds
    w, h = layer.bounds()
    # calculate scale &amp; apply
    s = aspectRatio( (w,h), newheight, height=True)
    layer.scale(s, s)
    return layer


</t>
<t tx="karstenw.20200419185049.1">def placeImage(canv, path, x, y, maxsize, name, width=True, height=False):
    """Create an image layer.
    
    """
    img1 = resizeImage(path, maxsize, width=width, height=height)
    top = canv.layer(img1, name=name)
    canv.top.translate(x, y)
    w, h, = canv.top.bounds()
    return top, w, h


</t>
<t tx="karstenw.20200419185056.1">def resizeImage( filepath, maxsize, orientation=True, width=True, height=True):

    """Get a downsampled image for use in layers.
    """
    f = False
    try:
        img = Image.open(filepath)
    except Exception, err:
        print("\nresizeImage() Image.open() FAILED '%s'" % filepath.encode("utf-8"))
        print(err)
        return ""

    # downsample the image
    if maxsize:
        w,h = aspectRatio( (img.size), maxsize,
                            height=height, width=height, assize=True)
        img = img.resize( (w,h), resample=Image.LANCZOS)
    # respect exif orientation
    if orientation:
        img = normalizeOrientationImage( img )
    if f:
        f.close()
    return img.convert("RGBA")


</t>
<t tx="karstenw.20200419185227.1">def filelist( folderpathorlist, pathonly=True ):
    """Walk a folder or a list of folders and return
    paths or ((filepath, size, lastmodified, mode) tuples..
    """

    folders = folderpathorlist
    if type(folderpathorlist) in (str, unicode):
        folders = [folderpathorlist]
    result = []
    for folder in folders:
        for root, dirs, files in os.walk( folder ):
            root = makeunicode( root )

            for thefile in files:
                thefile = makeunicode( thefile )
                basename, ext = os.path.splitext(thefile)

                # exclude dotfiles
                if thefile.startswith('.'):
                    continue

                # exclude the specials
                for item in (u'\r', u'\n', u'\t'):
                    if item in thefile:
                        continue

                filepath = os.path.join( root, thefile )

                record = filepath
                if not pathonly:
                    info = os.stat( filepath )
                    lastmodf = datetime.datetime.fromtimestamp( info.st_mtime )
                    islink = os.path.islink( filepath )
                    record = (filepath,
                              info.st_size,
                              lastmodf,
                              oct(info.st_mode),
                              islink )
                yield record


</t>
<t tx="karstenw.20200419185246.1">def imagefiles( folderpathorlist, pathonly=True ):
    """Get a list of images from a list of folders.

    folderpathorlist: is either a string with a path or a list of paths
    
    pathonly: if True return list of fullpath
              else: return a list of filetuples
    filetuple = 
        (path, filesize, lastmodf, mode, islink, width, height)
    
    """
    filetuples = filelist( folderpathorlist, pathonly=pathonly )
    exts = ".tif .tiff .gif .jpg .jpeg .png" # + " .eps"
    extensions = tuple( exts.split() )
    for filetuple in filetuples:
        path = makeunicode( filetuple )
        if not pathonly:
            path = filetuple[0]

        _, ext = os.path.splitext( path )
        if ext.lower() not in extensions:
            continue
        if pathonly:
            yield path
        else:
            path, filesize, lastmodf, mode, islink = filetuple
            s = (-1,-1)
            try:
                img = Image.open(path)
                s = img.size
                del img
            except:
                pass #continue
            filetuple = (path, filesize, lastmodf, mode, islink, s[0], s[1])
            yield filetuple


</t>
<t tx="karstenw.20200419185543.1">def hashFromString( s ):
    h = hashlib.sha1()
    h.update( s )
    return h.hexdigest()


</t>
<t tx="karstenw.20200419185608.1">def makeunicode(s, srcencoding="utf-8", normalizer="NFC"):
    typ = type(s)
    
    # convert to str first; for number types etc.
    if typ not in (str, unicode):
        s = str(s)
    if typ not in (unicode, ):
        try:
            s = unicode(s, srcencoding)
        except TypeError, err:
            print( "makeunicode(): %s" % repr(err) )
            print( "%s - %s" % (type(s), repr(s)) )
    if typ in (unicode,):
        s = unicodedata.normalize(normalizer, s)
    return s


</t>
<t tx="karstenw.20200419185624.1">def datestring(dt = None, dateonly=False, nospaces=True, nocolons=True):
    """Make an ISO datestring. The defaults are good for using the result of
    'datestring()' in a filename.
    """
    if not dt:
        now = str(datetime.datetime.now())
    else:
        now = str(dt)
    if not dateonly:
        now = now[:19]
    else:
        now = now[:10]
    if nospaces:
        now = now.replace(" ", "_")
    if nocolons:
        now = now.replace(":", "")
    return now


</t>
<t tx="karstenw.20200419185716.1">def loadImageWell( bgsize=(1024,768), minsize=(256,256),
                   maxfilesize=100000000, maxpixellength=16000,
                   pathonly=True, additionals=None, ignorelibs=False):
    """Find images imagewells or additional folders. 
       
        Params:
            bgsize - tuple with width and height for images to be classified background
            minsize - tuple with minimal width and height for images not to be ignored
            maxfilesize - in bytes. Images above this file size will be ignored
            maxpixellength - in pixels. Images above in either dimension will be ignored
            pathonly - return path or record
            additionals - list of folders to me considered for this run
            ignorelibs - if imagewells file should be ignored
    
        Returns:
            A dict of dicts with several image classifications.

            list of file paths if pathonly is True
            list of file records else.

    """


    # get all images from user image wells
    folders = []
    if not ignorelibs:
        folders = imagewells()
    
    if additionals:
        folders.extend( additionals )
    filetuples = imagefiles( folders, pathonly=False )

    tiles = []
    backgrounds = []
    proportions = {}
    fractions = {}

    result = {
        'allimages': [],
        'tiles': [],
        'backgrounds': [],
        'landscape': [],
        'portrait': [],
        'fractions': {},
        'WxH largest': "",
        'WxH smalles': "",
        'WxH median': "",
    }

    minw, minh = minsize
    bgw, bgh = bgsize
    smallestw, smallesth = 99999,99999
    largestw, largesth = 0,0
    medianw, medianh = 0,0
    slope = 1.0
    imagecount = 0
    for t in filetuples:
        path, filesize, lastmodified, mode, islink, w0, h0 = t
        folder, filename = os.path.split( path )
        basename, ext = os.path.splitext( filename )

        # filter minimal size
        if ext.lower() != ".eps":
            if (w0 &lt; minw) and (h0 &lt; minh):
                continue
            if (w0 &gt; maxpixellength) or (h0 &gt; maxpixellength):
                continue

        if (w0 &gt; maxpixellength) or (h0 &gt; maxpixellength):
            continue

        # filter max filesize
        if filesize &gt; maxfilesize:
            continue

        if w0 in (0, 0.0):
            continue
        if h0 in (0, 0.0):
            continue

        imagecount += 1

        # set stats
        if w0 &lt; smallestw:
            smallestw = w0
        if  h0 &lt; smallesth:
            smallesth = h0
        if w0 &gt; largestw:
            largestw = w0
        if  h0 &gt; largesth:
            largesth = h0

        proportion = "landscape"
        if h0 &gt; w0:
            proportion = "portrait"

        try:
            frac = Fraction(w0, h0)
        except TypeError, err:
            print(err)
            print(w0)
            print(h0)

        if pathonly:
            record = path
        else:
            record = (path, filesize, lastmodified, mode, islink,
                      w0, h0, proportion, frac)

        # candidate has at least canvas size and can be used as background
        result['allimages'].append( record )

        if (w0 &gt;= bgw) and (h0 &gt;= bgh):
            result['backgrounds'].append( record )
        else:
            result['tiles'].append( record )
        
        if frac not in result['fractions']:
            result['fractions'][frac] = []
        result['fractions'][frac].append( record )

        if proportion == "landscape":
            result['landscape'].append( record )
        else:
            result['portrait'].append( record )

    return result


</t>
<t tx="karstenw.20200419205343.1">#
# image well
#

</t>
<t tx="karstenw.20200419210659.1"></t>
<t tx="karstenw.20200421130950.1"># PIL interpolation modes
NEAREST = Image.NEAREST
BICUBIC = Image.BICUBIC
BILINEAR = Image.BILINEAR
LANCZOS = Image.LANCZOS
INTERPOLATION = Image.BICUBIC

LAYERS = []

# blend modes
NORMAL = "normal"
MULTIPLY = "multiply"
SCREEN = "screen"
OVERLAY = "overlay"
HUE = "hue"
COLOR = "color"

ADD = "add"
SUBTRACT = "subtract"
ADD_MODULO = "add_modulo"
SUBTRACT_MODULO = "subtract_modulo"
DIFFERENCE = "difference"


HORIZONTAL = 1
VERTICAL = 2

SOLID = "solid"
LINEAR = "linear"
RADIAL = "radial"
DIAMOND = "diamond"
COSINE = "cosine"
SINE = "sine"
ROUNDRECT = "roundrect"
RADIALCOSINE = "radialcosine"
QUAD = "quad"


</t>
<t tx="karstenw.20200421172034.1"></t>
<t tx="karstenw.20200421172203.1">def convolute(self, kernel, scale=None, offset=0):
    
    """A (3,3) or (5,5) convolution kernel.
    
    The kernel argument is a list with either 9 or 25 elements,
    the weight for each surrounding pixels to convolute.
    
    """
    
    if len(kernel)   ==  9: size = (3,3)
    elif len(kernel) == 25: size = (5,5)
    else:                   return
    
    if scale == None:
        scale = 0
        for x in kernel:
            scale += x
        if scale == 0:
            scale = 1
    
    f = ImageFilter.Kernel(size, kernel, scale=scale, offset=offset)
    
    # alpha = self.img.split()[3]
    alpha = self.img.getchannel("A")
    img = self.img.convert("RGB")
    # f = ImageFilter.BuiltinFilter()
    # f.filterargs = size, scale, offset, kernel
    
    img = img.filter(f)
    img = img.convert("RGBA")
    img.putalpha( alpha )
    self.img = img

</t>
<t tx="karstenw.20200421172500.1">def boxblur(self, radius=2):
    
    """Blurs the layer.
    
    """

    self.img = self.img.filter( ImageFilter.BoxBlur( radius ) )

</t>
<t tx="karstenw.20200430120743.1">#
# Some stack operations
# 
# some inspiration from a forth wiki page
# dup   ( a -- a a )
# drop  ( a -- )
# swap  ( a b -- b a )
# over  ( a b -- a b a )
# rot   ( a b c -- b c a )
# nip   ( a b -- b ) swap drop ;
# tuck  ( a b -- b a b ) swap over ;

</t>
<t tx="karstenw.20200430120752.1"></t>
<t tx="karstenw.20200430120922.1">if not name:
    name = "photobot_" + datestring()

folder, name = os.path.split( name )

if not folder:
    folder = os.path.abspath( os.curdir )
    folder = os.path.join( folder, "exports" )
folder = os.path.abspath( folder )

filename = name + ext
if name.endswith( ext ):
    filename = name

if not os.path.exists( folder ):
    try:
        os.makedirs( folder )
    except:
        pass
try:
    path = os.path.join( folder, filename )
    path = os.path.abspath( path )
except:
    pass

# if debugging is on export each layer separately
</t>
<t tx="karstenw.20200430120955.1">basename = "photobot_" + datestring() + "_layer_%i_%s" + ext

background = self.layers._get_bg()
background.name = "Background"
layers = range(1, len(self.layers) )
for i in layers:
    layer = self.layers[i]

    # Determine which portion of the canvas
    # needs to be updated with the overlaying layer.

    x = max(0, layer.x)
    y = max(0, layer.y)
    w = min(background.w, layer.x+layer.w)
    h = min(background.h, layer.y+layer.h)

    base = background.img.crop((0, 0, background.w, background.h))

    # Determine which piece of the layer
    # falls within the canvas.

    x = max(0, -layer.x)
    y = max(0, -layer.y)
    w -= layer.x
    h -= layer.y

    blend = layer.img.crop((x, y, w, h))

    # alpha = blend.split()[3]
    alpha = blend.getchannel("A")
    buffer = Image.composite(blend, base, alpha)

    n = basename % (i, layer.name)
    path = os.path.join( folder, n )
    buffer.save( path, format=format, optimize=False)
    print( "exort() DBG: '%s'" % path.encode("utf-8") )
</t>
<t tx="karstenw.20200430124808.1">@property
def dup(self):
    """Interface to top layer.
    
    """
    layer = self.top.copy()
    layer.canvas = self
    self.layers.append( layer )
    return self.top

</t>
<t tx="karstenw.20201006211515.1"></t>
<t tx="karstenw.20201006211521.1"># heavily inspired by https://www.nodebox.net/code/index.php/Landslide
@others
@language python
@tabwidth -4
</t>
<t tx="karstenw.20201006211549.1"># heavily inspired by https://www.nodebox.net/code/index.php/Landslide
@others
@language python
@tabwidth -4
</t>
<t tx="karstenw.20201006211613.1">import sys, os

import pprint
pp = pprint.pprint
kwdbg = 0

# need a different name for nodebox
import random as rnd

import libgradient

if kwdbg:
    # make random choices repeatable for debugging
    rnd.seed(0)

# width and height of destination image
W, H =  800,  600
W, H = 1024,  768
W, H = 1280,  800
W, H = 1440,  900
W, H = 1920, 1080

# import photobot
try:
    pb = ximport("photobot")
    size(W, H)
    background( 0.333 )
except ImportError:
    pb = ximport("__init__")
    reload(pb)
    size(W, H)
    background( 0.333 )
except NameError:
    import photobot as pb
    WIDTH, HEIGHT = W, H
</t>
<t tx="karstenw.20201006211616.1">import sys, os

import pprint
pp = pprint.pprint
kwdbg = False

# need a different name
import random as rnd

if kwdbg:
    # make random choices repeatable for debugging
    rnd.seed(0)

try:
    size(0,0)
    # W, H = 1024,768
    W, H = int(WIDTH),int(HEIGHT)
except:
    W = 1920
    H = 1050

# import photobot
try:
    pb = ximport("photobot")
    size(W, H)
    background( 0.333 )
except ImportError:
    pb = ximport("__init__")
    reload(pb)
    size(W, H)
    background( 0.333 )
except NameError:
    import photobot as pb
    WIDTH, HEIGHT = W, H
RATIO = WIDTH / HEIGHT

# load the image library
# check for command line folders
additionals = sys.argv[1:]

# get all images from user image wells
imagewell = pb.loadImageWell(   bgsize=(W,H),
                                minsize=(256,256),
                                pathonly=True,
                                additionals=additionals)

# tiles are images &gt;256x256 and &lt;=1024x768
tiles = imagewell['tiles']

# backgrounds are images &gt;1024x768
backgrounds = imagewell['backgrounds']
rnd.shuffle(tiles)
rnd.shuffle(backgrounds)

print "tiles:", len(tiles)
print "backgrounds:", len(backgrounds)


# CONFIGURATION

# create the canvas
c = pb.canvas( WIDTH, HEIGHT)
c.fill( (85,85,85) )


# CONFIGURATION

columns = 5
rows = 3

randomblur = 0
randomflip = 0
paintoverlay = 0
gilb =0


# 
y_offset = HEIGHT / float(rows)
y_offset = int(round(y_offset))


# 
if 0:
    bgimage = backgrounds.pop()
    top = c.layer(bgimage)
    w, h = c.top.bounds()
    w1,h1 = pb.aspectRatio( (w,h), WIDTH, height=False, assize=True )
    c.top.scale(w1,h1)
else:
    bgimage = backgrounds.pop()
    pb.placeImage(c, bgimage, 0, 0, WIDTH, "bgimage")
print "Background:", bgimage.encode("utf-8")


for j in range(rows):
    colw = 0
    for i in range(columns):

        # new layer with a random image
        top = c.layer( tiles.pop() )

        # get current image bounds
        w, h = c.top.bounds()

        # calculate scale &amp; apply
        s = pb.aspectRatio( (w,h), y_offset, height=True)
        c.top.scale(s, s)

        # uniform
        layer = pb.cropImageToRatioHorizontal( c.top, RATIO )

        # add contrast
        c.top.contrast(1.1)

        # get the new image bounds
        w, h = c.top.bounds()

        r = 0.4 
        r = rnd.random()
        # 10%
        if r &lt; 0.25:
            # create a dual ramp gradient
            _ = c.gradient(pb.LINEAR, w/2, h)
            c.top.flip( pb.HORIZONTAL )

            # layer translate half a pict right
            c.top.translate(w/2, j*y_offset)

            # create another gradient layer and merge with first gradient
            top = c.gradient(pb.LINEAR, w/2, h)
            # merge both gradients; destroys top layer
            c.merge([ top-1 , top ])
        elif 0.25 &lt;= r &lt; 0.5:
            #print "SINE"
            top = c.gradient(pb.SINE, w, h)
            
        elif 0.6 &lt;= r &lt; 0.75:
            #print "RADIALCOSINE"
            top = c.gradient(pb.RADIALCOSINE, w, h)
            c.top.invert()
        else:
            #print "ROUNDRECT"
            # 25%
            top = c.gradient(pb.ROUNDRECT, w, h, radius=int(w/5.0))

        c.top.brightness(1.4)

        # mask destroys top layer
        c.top.mask()
        
        c.top.translate(colw+i*w, j*y_offset)
        c.top.opacity( 66 + rnd.random() * 29 )

        if randomblur:
            if rnd.random() &gt; 0.5:
                c.top.flip()

            if rnd.random() &gt; 0.5:
                c.top.blur()

if 1:
    # orange hue mask finish
    top = c.fill((200,100,0))
    c.top.opacity(30)
    c.top.hue()

if paintoverlay:
    # paint overlay
    top = c.layer( os.path.abspath("./paint.jpg") )
    w, h = c.top.bounds()
    xs = WIDTH / float(w)
    ys = HEIGHT / float(h)
    s = max(xs,ys)
    c.top.scale(s, s)
    c.top.opacity(10)
    c.top.overlay()

c.draw(0, 0)
</t>
<t tx="karstenw.20201006211627.1">RATIO = WIDTH / HEIGHT

# load the image library
# check for command line folders
additionals = sys.argv[1:]

# get all images from user image wells
imagewell = pb.loadImageWell(   bgsize=(W,H),
                                minsize=(256,256),
                                pathonly=True,
                                additionals=additionals)

# tiles are images &gt;256x256 and &lt;=1024x768
tiles = imagewell['tiles']

# backgrounds are images &gt;W,H
backgrounds = imagewell['backgrounds']

rnd.shuffle(tiles)
rnd.shuffle(backgrounds)

print "tiles:", len(tiles)
print "backgrounds:", len(backgrounds)


# create the canvas
c = pb.canvas( WIDTH, HEIGHT)
c.fill( (85,85,85) )


# CONFIGURATION

columns = 3
rows = 3

enoughTiles = len(tiles) &gt; (columns * 2 * rows)

randomblur = 1
randomflip = 1
paintoverlay = 1
gilb = 1


# 
y_offset = HEIGHT / float(rows)
y_offset = int(round(y_offset))




# background image
bgimage = backgrounds.pop()
pb.placeImage(c, bgimage, 0, 0, WIDTH, "Image 1")
# print "Background:", bgimage.encode("utf-8")


cols = -1
for j in range(rows):
    colw = 0
    cols += 1
    while colw &lt; WIDTH:
        if 0: # kwdbg:
            print '-' * 20
            print "Col:" , cols

        # create image in canvas at 0,0
        nextpictpath = tiles.pop()

        # new layer with a random image
        # c.layer returns the index of the top layer
        topidx = c.layer( nextpictpath )

        # get current image bounds
        w, h = c.top.bounds()

        
        # calculate scale &amp; apply
        s = pb.aspectRatio( (w,h), y_offset, height=True)
        c.top.scale(s, s)

        # get current image bounds
        w, h = c.top.bounds()

        # create a random mask gradient for this tile
        libgradient.makerandomgradient( c, w, h, j*y_offset )
        c.top.mask()


        # P: 0.5 # flip the tile
        if randomblur:
            if rnd.random() &gt; 0.5:
                c.top.flip()

        # P: 0.5 # add blur
        if randomflip:
            if rnd.random() &gt; 0.5:
                c.top.blur()

        w, h = c.top.bounds()
        c.top.translate(colw, j*y_offset)
        colw += w


if 1:
    # orange hue mask finish
    topidx = c.fill((200,100,0))
    c.top.opacity(30)
    c.top.hue()

paintfile = os.path.abspath("./paint.jpg")
if paintoverlay:
    # paint overlay
    if os.path.exists( paintfile ):
        if kwdbg:
            print "paint overlay:", paintfile
        topidx = c.layer( paintfile )
        w, h = c.top.bounds()
        xs = WIDTH / float(w)
        ys = HEIGHT / float(h)
        s = max(xs,ys)
        c.top.scale(s, s)
        # c.top.opacity( 90 )
        c.top.overlay()

c.draw(0,0)

</t>
<t tx="karstenw.20201009153259.1">#
# Image Sectors
#

</t>
<t tx="karstenw.20201009153305.1"></t>
<t tx="karstenw.20201010122613.1">class TiledImage(object):
    ""
    @others


</t>
<t tx="karstenw.20201010122902.1">def __init__(self, tilesize, wtiles, htiles):
    self.tilesize = int( self.tilesize )
    self.wtiles = int( self.wtiles )
    self.htiles = int( self.htiles )
    tiles = self.wtiles * self.htiles 
    self.tilebam = [ 0 ] * tiles

    self.w = tilesize * wtiles
    self.h = tilesize = htiles

    self.img = None
    self.layout = []
    

</t>
<t tx="karstenw.20201010123021.1">def makeimage( self ):
    pass


def makelayout( self ):
    pass

</t>
<t tx="karstenw.20201010124204.1">class Layout( object ):
    ""
    @others


</t>
<t tx="karstenw.20201010124230.1">def __init__(self):
    pass


</t>
<t tx="karstenw.20201022144341.1"></t>
<t tx="karstenw.20201022144702.1">def innerRect( w0, h0, w1, h1):
    """Create an inner size crop rect (0,0,w1,h1) + translation
    """
    pass


</t>
<t tx="karstenw.20210211171614.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20210211171653.1">"""
Find a nice cutoff to SmallTalk. You dont want the whole package.
"""

</t>
<t tx="karstenw.20210211171653.10"># left right top bottom
@classmethod
def leftRightTopBottom(cls, left, right, top, bottom):
    return cls( Point(left,top), Point(right,bottom) )

</t>
<t tx="karstenw.20210211171653.11"></t>
<t tx="karstenw.20210211171653.12">def withRight( self, x ):
    return Rectangle( self.porigin, Point( x, self.pcorner.y))
def withLeft( self, x ):
    return Rectangle( Point(x, self.porigin.y), self.pcorner)
def withBottom( self, y ):
    return Rectangle( self.porigin, Point( self.pcorner.x, y) )
def withTop( self, y ):
    return Rectangle( Point(self.porigin.x, y), self.pcorner )

def withSideSetTo( self, side, val ):
    if side == "left":
        return Rectangle( Point(val, self.porigin.y), self.pcorner )
    elif side == "right":
        return Rectangle( self.origin, Point(val, self.pcorner.y) )
    elif side == "top":
        return Rectangle( Point(self.porigin.x, val), self.pcorner )
    elif side == "bottom":
        return Rectangle( self.porigin, Point(self.pcorner.x, val) )

def amountToTranslateWithin( self, aRectangle ):
    """Answer a Point, delta, such that self + delta is forced within aRectangle.
    Altered so as to prefer to keep self topLeft inside when all of self
    cannot be made to fit 7/27/96 di"""
    dx = dy = 0
    if self.right &gt; aRectangle.right:
        dx = aRectangle.right - self.right

    if self.bottom &gt; aRectangle.bottom:
        dy = aRectangle.bottom - self.bottom

    if (self.left + dx) &lt; aRectangle.left:
        dx = aRectangle.left - self.left

    if (self.top + dy) &lt; aRectangle.top:
        dy = aRectangle.top - self.top

    return Point(dx,dy)


def areasOutside( self, aRectangle ):
    """Answer an Array of Rectangles comprising the parts of the receiver not intersecting aRectangle."""

    areas = []
    if not ((self.origin &lt;= aRectangle.corner) and (aRectangle.origin &lt;= self.corner)):
        return [self]

    if aRectangle.origin.y &gt; self.origin.y:
        yOrigin = aRectangle.origin.y
        areas.append( Rectangle( self.origin, Point(self.corner.x, yOrigin)) )
    else:
        yOrigin = self.origin.y

    if 	aRectangle.corner.y &lt; corner.y:
        yCorner = aRectangle.corner.y
        areas.append( Rectangle( Point(self.origin.x, yCorner ), self.corner) )
    else:
        yCorner = self.corner.y

    if aRectangle.origin.x &gt; self.origin.x:
        areas.append( Rectangle( Point(self.origin.x, yOrigin), Point(aRectangle.origin.x, yCorner)) )

    if aRectangle.corner.x &lt; self.corner.x:
        areas.append( Rectangle( Point(self.corner.x, yOrigin), Point(self.corner.x, yCorner) ))
    return areas


def bordersOnAlong( self, her, herSide ):
    if (   (herSide == b"right" and self.left == her.right)
        or (herSide == b"left"  and self.right == her.left)):
        return max(self.top, her.top) &lt; min(self.bottom, her.bottom)

    if (   (herSide == b"bottom" and self.top == her.bottom)
        or (herSide == b"top"  and self.bottom == her.top)):
        return  max(self.left, her.left) &lt; min(self.right, her.right)
    return False


def encompass( self, aPoint ):
    """Answer a Rectangle that contains both the receiver and aPoint.  5/30/96 sw"""
    return Rectangle( min(self.origin, aPoint.origin), max(self.corner, aPoint.corner) )

def expandBy( self, delta ):
    """Answer a Rectangle that is outset from the receiver by delta. delta is a 
       Rectangle, Point, or scalar."""
    if isinstance(delta, Rectangle):
        return Rectangle( self.origin - delta.origin, self.corner + delta.corner)
    else:
        return Rectangle( self.origin - delta, self.corner + delta)

    
def extendBy( self, delta ):
    """Answer a Rectangle with the same origin as the receiver, but whose corner is offset by delta. delta is a
       Rectangle, Point, or scalar."""

    if isinstance(delta, Rectangle):
        return Rectangle( self.origin, self.corner + delta.corner )
    return Rectangle( self.origin, self.corner + delta)


# def forPoint: aPoint closestSideDistLen: sideDistLenBlock
# has block

def insetBy( self, delta ):
    """Answer a Rectangle that is inset from the receiver by delta. delta is a 
       Rectangle, Point, or scalar."""
    if isinstance(delta, Rectangle):
        return Rectangle( self.origin + delta.origin, self.corner - delta.corner )
    return Rectangle( self.origin + delta, self.corner - delta)


def insetOriginAndCornerBy( self, originDeltaPoint, cornerDeltaPoint ):
    """Answer a Rectangle that is inset from the receiver by a given amount in
       the origin and corner."""
    return Rectangle( self.origin + originDeltaPoint, self.corner - cornerDeltaPoint )


def intersect( self, aRectangle ):
    """Answer a Rectangle that is the area in which the receiver overlaps with 
       aRectangle. Optimized for speed; old code read:
        ^Rectangle 
            origin: (origin max: aRectangle origin)
            corner: (corner min: aRectangle corner)"""
    if 0: # old code
        return Rectangle( max(self.origin, aRectangle.origin),
                          min(sel.corner, aRectangle.corner) )
    else:
        left = right = top = bottom = 0
        aPoint = aRectangle.origin
        if aPoint.x &gt; origin.x:
            left = aPoint.x
        else:
            left = origin.x

        if aPoint.y &gt; origin.y:
            top = aPoint.y
        else:
            top = origin.y

        aPoint = aRectangle.corner
        if aPoint.x &lt; self.corner.x:
            right = aPoint.x
        else:
            right = self.corner.x
        
        if aPoint.y &lt; corner.y:
            bottom = aPoint.y
        else:
            bottom = corner.y
        return Rectangle( (left,top), (right, bottom) )


def merge( self, aRectangle ):
    """Answer a Rectangle that contains both the receiver and aRectangle."""
    return Rectangle( min(self.origin, aRectangle.origin), max(self.corner, aRectangle.corner) )

def outsetBy( self, delta ):
    """Answer a Rectangle that is outset from the receiver by delta. delta is a 
       Rectangle, Point, or scalar."""
    if isinstance( delta, Rectangle ):
        return Rectangle(self.origin - delta.origin, self.corner + delta.corner)
    else:
        return Rectangle(self.origin - delta, self.corner + delta)


def pointNearestTo( self, aPoint ):
    """Return the point on my border closest to aPoint"""
    side = ""
    if self.containsPoint( aPoint ):
        pass
        """
            [side _ self sideNearestTo: aPoint.
            side == #right ifTrue: [^ self right @ aPoint y].
            side == #left ifTrue: [^ self left @ aPoint y].
            side == #bottom ifTrue: [^ aPoint x @ self bottom].
            side == #top ifTrue: [^ aPoint x @ self top]]
        """
    else:
        pass
        """
        (self containsPoint: aPoint)
            ifTrue:
                [side _ self sideNearestTo: aPoint.
                side == #right ifTrue: [^ self right @ aPoint y].
                side == #left ifTrue: [^ self left @ aPoint y].
                side == #bottom ifTrue: [^ aPoint x @ self bottom].
                side == #top ifTrue: [^ aPoint x @ self top]]
            ifFalse:
                [^ aPoint adhereTo: self]! !
        """

"""
quickMerge: aRectangle 
    "Answer the receiver if it encloses the given rectangle or the merge of the two rectangles if it doesn't. THis method is an optimization to reduce extra rectangle creations."

    | useRcvr rOrigin rCorner minX maxX minY maxY |
    useRcvr _ true.
    rOrigin _ aRectangle topLeft.
    rCorner _ aRectangle bottomRight.
    minX _ rOrigin x &lt; origin x ifTrue: [useRcvr _ false. rOrigin x] ifFalse: [origin x].
    maxX _ rCorner x &gt; corner x ifTrue: [useRcvr _ false. rCorner x] ifFalse: [corner x].
    minY _ rOrigin y &lt; origin y ifTrue: [useRcvr _ false. rOrigin y] ifFalse: [origin y].
    maxY _ rCorner y &gt; corner y ifTrue: [useRcvr _ false. rCorner y] ifFalse: [corner y].

    useRcvr
        ifTrue: [^ self]
        ifFalse: [^ Rectangle origin: minX@minY corner: maxX@maxY].
! !


rectanglesAt: y height: ht
    (y+ht) &gt; self bottom ifTrue: [^ Array new].
    ^ Array with: (origin x @ y corner: corner x @ (y+ht))! !

!Rectangle methodsFor: 'rectangle functions' stamp: 'di 10/21/1998 15:09'!
sideNearestTo: aPoint
    | distToLeft distToRight distToTop distToBottom closest side |
    distToLeft _ aPoint x - self left.
    distToRight _ self right - aPoint x.
    distToTop _ aPoint y - self top.
    distToBottom _ self bottom - aPoint y.
    closest _ distToLeft. side _ #left.
    distToRight &lt; closest ifTrue: [closest _ distToRight. side _ #right].
    distToTop &lt; closest ifTrue: [closest _ distToTop. side _ #top].
    distToBottom &lt; closest ifTrue: [closest _ distToBottom. side _ #bottom].
    ^ side
"
 | r | r _ Rectangle fromUser.
Display border: r width: 1.
[Sensor anyButtonPressed] whileFalse:
    [(r sideNearestTo: Sensor cursorPoint) , '      ' displayAt: 0@0]
"! !

!Rectangle methodsFor: 'rectangle functions'!
translatedToBeWithin: aRectangle
    "Answer a copy of the receiver that does not extend beyond aRectangle.  7/8/96 sw"

    ^ self translateBy: (self amountToTranslateWithin: aRectangle)! !

!Rectangle methodsFor: 'rectangle functions'!
withBottom: y 
    "Return a copy of me with a different bottom y"
    ^ origin x @ origin y corner: corner x @ y! !

!Rectangle methodsFor: 'rectangle functions'!
withHeight: height 
    "Return a copy of me with a different height"
    ^ origin corner: corner x @ (origin y + height)! !

!Rectangle methodsFor: 'rectangle functions'!
withLeft: x 
    "Return a copy of me with a different left x"
    ^ x @ origin y corner: corner x @ corner y! !

!Rectangle methodsFor: 'rectangle functions'!
withRight: x 
    "Return a copy of me with a different right x"
    ^ origin x @ origin y corner: x @ corner y! !

!Rectangle methodsFor: 'rectangle functions'!
withSide: side setTo: value  "return a copy with side set to value"
    ^ self perform: (#(withLeft: withRight: withTop: withBottom: )
                            at: (#(left right top bottom) indexOf: side))
        with: value! !

!Rectangle methodsFor: 'rectangle functions' stamp: 'di 9/8/1999 21:25'!
withSideOrCorner: side setToPoint: newPoint
    "Return a copy with side set to newPoint"

    ^ self withSideOrCorner: side setToPoint: newPoint minExtent: 0@0! !

!Rectangle methodsFor: 'rectangle functions' stamp: 'bf 9/10/1999 16:16'!
withSideOrCorner: side setToPoint: newPoint minExtent: minExtent
    "Return a copy with side set to newPoint"
    ^self withSideOrCorner: side setToPoint: newPoint minExtent: minExtent
        limit: ((#(left top) includes: side) ifTrue: [SmallInteger minVal] ifFalse: [SmallInteger maxVal])! !

!Rectangle methodsFor: 'rectangle functions' stamp: 'bf 9/10/1999 16:07'!
withSideOrCorner: side setToPoint: newPoint minExtent: minExtent limit: limit
    "Return a copy with side set to newPoint"
    side = #top ifTrue: [^ self withTop: (newPoint y min: corner y - minExtent y max: limit + minExtent y)].
    side = #bottom ifTrue: [^ self withBottom: (newPoint y min: limit - minExtent y max: origin y + minExtent y)].
    side = #left ifTrue: [^ self withLeft: (newPoint x min: corner x - minExtent x max: limit + minExtent x)].
    side = #right ifTrue: [^ self withRight: (newPoint x min: limit - minExtent x max: origin x + minExtent x)].
    side = #topLeft ifTrue: [^ (newPoint min: corner - minExtent) corner: self bottomRight].
    side = #bottomRight ifTrue: [^ self topLeft corner: (newPoint max: origin + minExtent)].
    side = #bottomLeft ifTrue: [^ self topRight rect: ((newPoint x min: corner x - minExtent x) @ (newPoint y max: origin y + minExtent y))].
    side = #topRight ifTrue: [^ self bottomLeft rect: ((newPoint x max: origin x + minExtent x) @ (newPoint y min: corner y - minExtent y))].! !

!Rectangle methodsFor: 'rectangle functions'!
withTop: y 
    "Return a copy of me with a different top y"
    ^ origin x @ y corner: corner x @ corner y! !

!Rectangle methodsFor: 'rectangle functions'!
withWidth: width 
    "Return a copy of me with a different width"
    ^ origin corner: (origin x + width) @ corner y! !

"""

</t>
<t tx="karstenw.20210211171653.13">def innerSquare(self):
    pass


def outerSquareRect(self):
    pass


</t>
<t tx="karstenw.20210211171653.2">class Point(object):
    "Translated from a Squeak 3.7 image"
    @others



</t>
<t tx="karstenw.20210211171653.3">def __init__(self, x, y):
    self.x = float(x)
    self.y = float(y)

def __repr__( self ):
    return u"Point( %.2f, %.2f )" % (self.x, self.y)

</t>
<t tx="karstenw.20210211171653.5">class Rectangle(object):
    "Translated from a Squeak 3.7 image"

    @others

</t>
<t tx="karstenw.20210211171653.6">def __init__(self, origin, corner):
    if isinstance(origin, Point):
        self.porigin = origin
    else:
        self.porigin = Point( *origin )
    if isinstance(corner, Point):
        self.pcorner = corner
    else:
        self.pcorner = Point( *corner )


def __repr__( self ):
    return u"Rectangle( %s, %s )" % (repr(self.porigin), repr(self.pcorner) )


</t>
<t tx="karstenw.20210211171653.7"></t>
<t tx="karstenw.20210211171653.8"></t>
<t tx="karstenw.20210211171653.9"># center: extent:
@classmethod
def centerExtent(cls, centerPoint, extentPoint):
    """Answer an instance of me whose center is centerPoint and width 
       by height is extentPoint."""
    dx = round( extentPoint.x / 2.0 )
    dy = round( extentPoint.y / 2.0 )
    originPoint = Point( centerPoint.x - round( extentPoint.x / 2.0 ),
                         centerPoint.y - round( extentPoint.y / 2.0 ))
    cornerPoint = originPoint + extentPoint
    return cls( originPoint, cornerPoint )


@classmethod
def originExtent( cls, originPoint, extentPoint ):
    """Answer an instance of me whose top left corner is originPoint and width 
       by height is extentPoint."""
    return cls( originPoint, originPoint + extentPoint )


</t>
<t tx="karstenw.20210211171734.1">

import sys
import os
import math

import pdb


__all__ = ['Point', 'Rectangle']


</t>
<t tx="karstenw.20210213125927.1">def __lt__(self, other):
    return (self.x &lt; other.x) and (self.y &lt; other.y)
def __le__(self, other):
    return (self.x &lt;= other.x) and (self.y &lt;= other.y)

def __gt__(self, other):
    return (self.x &gt; other.x) and (self.y &gt; other.y)
def __ge__(self, other):
    return (self.x &gt;= other.x) and (self.y &gt;= other.y)

def __eq__(self, other):
    return (self.x == other.x) and (self.y == other.y)
def __ne__(self, other):
    return (self.x != other.x) or (self.y != other.y)

def __add__( self, other):
    if isinstance(other, Point):
        return Point( self.x + other.x, self.y + other.y )
    return Point( self.x + other, self.y + other )

def __sub__( self, other):
    if isinstance(other, Point):
        return Point( self.x - other.x, self.y - other.y )
    return Point( self.x - other, self.y - other )

def __mul__( self, other):
    if isinstance(other, Point):
        return Point( self.x * other.x, self.y * other.y )
    return Point( self.x * other, self.y * other )


</t>
<t tx="karstenw.20210216164600.1"></t>
<t tx="karstenw.20210216164604.1">def makePoint( *args  ):
    "Tries to create a Point from args."
    n = len(args)
    if n == 1:
        if isinstance(args, Point):
            return args
        else:
            return Point( args[0][0], args[0][1] )
    elif n == 2:
        return Point( args[0], args[1] )
    return None


def sign( number ):
    if number &gt; 0:
        return +1
    elif number &lt; 0:
        return -1
    return 0


</t>
<t tx="karstenw.20210216165734.1"># origin
def getorigin(self):
    return self.porigin
def setorigin(self, val):
    self.porigin = val
origin = property(getorigin, setorigin)

# corner
def getcorner(self):
    return self.pcorner
def setcorner(self, val):
    self.pcorner = val
corner = property(getcorner, setcorner)

</t>
<t tx="karstenw.20210216165815.1"># height
def getheight(self):
    return self.pcorner.y - self.porigin.y
def setheight( self, height):
    self.pcorner.y = self.porigin.y + height
height = property(getheight, setheight)

#  width
def getwidth(self):
    return self.pcorner.x - self.porigin.x
def setwidth( self, width):
    self.pcorner.x = self.porigin.x + width
width = property(getwidth, setwidth)

# area
def getarea( self ):
    return self.width * self.height
area = property(getarea)

</t>
<t tx="karstenw.20210216165832.1"># top
def gettop( self ):
    return self.porigin.y
def settop( self, val ):
    self.porigin.y = val
top = property( gettop, settop )

# bottom
def getbottom( self ):
    return self.pcorner.y
def setbottom( self, val ):
    self.pcorner.y = val
bottom = property( getbottom, setbottom )

# left
def getleft( self ):
    return self.porigin.x
def setleft( self, val ):
    self.porigin.x = val
left = property( getleft, setleft )

# right
def getright( self ):
    return self.pcorner.x
def setright( self, val ):
    self.pcorner.x = val
right = property( getright, setright )


</t>
<t tx="karstenw.20210216170708.1"># topleft
def gettopleft( self ):
    return self.porigin
def settopleft( self, *args):
    self.porigin = makepoint( args )
topleft = property( gettopleft, settopleft )

# topright
def gettopright( self ):
    return Point( self.pcorner.x, self.porigin.y )
def settopright( self, *args):
    p = makepoint( args )
    self.pcorner.x = p.x
    self.porigin.y = p.y
topright = property( gettopright, settopright )

# bottomleft
def getbottomleft( self ):
    return Point( self.porigin.x, self.pcorner.y )
def setbottomleft( self, *args):
    p = makepoint( args )
    self.porigin.x = p.x
    self.pcorner.y = p.y
bottomleft = property( getbottomleft, setbottomleft )

# bottomright
def getbottomright( self ):
    return self.pcorner
def setbottomright( self, *args):
    self.pcorner = makepoint( args )
bottomright = property( getbottomright, setbottomright )

</t>
<t tx="karstenw.20210216170803.1"># center
def getcenter( self ):
    return Point( self.left + self.width / 2.0,
                  self.top + self.height / 2.0 )
def setcenter( self, *args):
    self.porigin = makepoint( args )
center = property( getcenter, setcenter )

</t>
<t tx="karstenw.20210216171723.1"># bottomcenter
def bottomcenter( self ):
    return Point( self.center.x, self.bottom )
bottomcenter = property( bottomcenter )

# topcenter
def topcenter( self ):
    return Point( self.center.x, self.top )
topcenter = property( topcenter )

# leftcenter
def leftcenter( self ):
    return Point( self.left, self.center.y )
leftcenter = property( leftcenter )

# rightcenter
def rightcenter( self ):
    return Point( self.right, self.center.y )
rightcenter = property( rightcenter )

</t>
<t tx="karstenw.20210216171724.1">def getcorners( self ):
    return [
        self.topleft,
        self.bottomleft,
        self.bottomright,
        self.topright
    ]

def setcorners( self, topLeft, bottomleft, bottomright, topright ):
    self.origin( topLeft )
    self.corner( bottomRight )

corners = property( getcorners )

def getextent( self ):
    return self.pcorner - self.porigin

def setextent( self, aPoint ):
    self.corner( self.origin + aPoint )

extent = property( getextent, setextent )


</t>
<t tx="karstenw.20210216171724.2"></t>
<t tx="karstenw.20210216171724.3"></t>
<t tx="karstenw.20210216171724.4"></t>
<t tx="karstenw.20210216171724.5"></t>
<t tx="karstenw.20210216174810.1">def __eq__( self, other ):
    return (self.porigin == other.porigin) and (self.pcorner == other.pcorner)

def __ne__( self, other ):
    return (self.porigin != other.porigin) or (self.pcorner != other.pcorner)

</t>
<t tx="karstenw.20210217105319.1">
def containsPoint( self, aPoint ):
    "Answer whether aPoint is within the receiver."
    return (self.origin &lt;= aPoint) and (aPoint &lt; self.corner)


def containsRect( self, aRect ):
    """Answer whether aRect is within the receiver (OK to coincide)."""
    return (aRect.origin &gt;= self.origin) and (aRect.corner &lt;= self.corner)

def fullIntersects( self, aRectangle ):
    """Answer whether aRectangle intersects the receiver anywhere.
       Optimized
       
       old code answered:
        (origin max: aRectangle origin) &lt; (corner min: aRectangle corner)"""

    if 0: # old code
        return (  max( self.origin, aRectangle.origin )
                &lt; min(self.corner, aRectangle.corner))
    else:
        if self.containsPoint( aRectangle.origin ) or self.containsPoint( aRectangle.corner ):
            return True

        if self.corner &lt; aRectangle.origin:
            return false

        rOrigin = aRectangle.origin
        rCorner = aRectangle.corner
        if rCorner.x &lt;= self.origin.x:
            return False
        if rCorner.y &lt;= self.origin.y:
            return False
        if rOrigin.x &gt;= self.corner.x:
            return False
        if rOrigin.y &gt;= self.corner.y:
            return False
        return True

def hasPositiveExtent( self ):
    return (self.corner.x &gt; self.origin.x) and (self.corner.y &gt; self.origin.y)

def intersects( self, aRectangle ):
    """Answer whether aRectangle intersects the receiver anywhere.
    Optimized

    old code answered:
        (origin max: aRectangle origin) &lt; (corner min: aRectangle corner)"""
    
    # | rOrigin rCorner |
    rOrigin = aRectangle.origin
    rCorner = aRectangle.corner
    if rCorner.x &lt;= self.origin.x:
        return False
    if rCorner.y &lt;= self.origin.y:
        return False
    if rOrigin.x &gt;= self.corner.x:
        return False
    if rOrigin.y &gt;= self.corner.y:
        return False
    return True


def isTall( self ):
    return self.height &gt; self.width

def isWide( self ):
    return self.width &gt; self.height

def isZero( self ):
    return self.origin.isZero() and self.corner.isZero()

def rounded( self ):
    """Answer a Rectangle whose origin and corner are rounded."""
    return Rectangle( self.origin.rounded(), self.corner.rounded() )

def truncateTo( self, grid ):
    """Answer a Rectangle whose origin and corner are truncated to grid x and grid y."""
    return Rectangle( self.origin.trincateTo( grid ), self.corner.truncateTo( grid ) )

def truncated( self ):
    if int(self.origin.x) == self.origin.x:
        if int(self.origin.y) == self.origin.y:
            if int(self.corner.x) == self.corner.x:
                if int(self.corner.y) == self.corner.y:
                    return self
    return Rectangle( self.origin.truncated(), self.corner.truncated() )

</t>
<t tx="karstenw.20210217123206.1">def isZero( self ):
    epsilon = 0.00001
    if 0.0 - epsilon &lt; self.x &lt; 0.0 + epsilon:
        if 0.0 - epsilon &lt; self.y &lt; 0.0 + epsilon:
            return True
    return False


def rounded( self ):
    if (int(self.x) == self.x) and (int(self.y) == self.y ):
        return self
    return Point( rounded( self.x, 0 ), rounded( self.y, 0) )

def truncateTo( self, grid ):
    """Answer a Point that is the receiver's x and y truncated to grid x and 
    grid y."""
    gridPoint = makepoint(grid)
    x = (self.x // gridPoint.x) * gridPoint.x
    y = (self.y // gridPoint.y) * gridPoint.y
    return Point(x,y)

def truncated( self ):
    """Answer a Point whose x and y coordinates are integers.
    Answer the receiver if its coordinates are already integral."""
    if (int(self.x) == self.x) and (int(self.y) == self.y ):
        return self
    return Point( int( self.x ), int(self.y) )


</t>
<t tx="karstenw.20210217132749.1">def alignWith( self, aPoint1, aPoint2 ):
    return self.translateBy( aPoint2 - aPoint1 )

def centeredBeneath( aRectangle ):
    """Move the reciever so that its top center point coincides with the bottom
       center point of aRectangle.  5/20/96 sw:"""
    return self.alignWith( self.topCenter, self.bottomCenter )


def flipByCenterAt( self, direction, aPoint ):
    """Return a copy flipped #vertical or #horizontal, about aPoint."""
    return Rectangle( self.origin.flipBy( direction ), 0) 
    # ^ (origin flipBy: direction centerAt: aPoint)
    #           rect: (corner flipBy: direction centerAt: aPoint)

"""
!Rectangle methodsFor: 'transforming' stamp: 'JMM 10/21/2003 17:26'!
newRectButtonPressedDo: newRectBlock 
    "Track the outline of a new rectangle until mouse button 
    changes. newFrameBlock produces each new rectangle from the 
    previous. Only tracks while mouse is down."
    | rect newRect buttonNow aHand delay |
    delay _ Delay forMilliseconds: 10.
    buttonNow _ Sensor anyButtonPressed.
    rect _ self.
    Display
        border: rect
        width: 2
        rule: Form reverse
        fillColor: Color gray.
    [buttonNow]
        whileTrue: [delay wait.
            buttonNow _ Sensor anyButtonPressed.
            newRect _ newRectBlock value: rect.
            newRect = rect
                ifFalse: [Display
                        border: rect
                        width: 2
                        rule: Form reverse
                        fillColor: Color gray.
                    Display
                        border: newRect
                        width: 2
                        rule: Form reverse
                        fillColor: Color gray.
                    rect _ newRect]].
    Display
        border: rect
        width: 2
        rule: Form reverse
        fillColor: Color gray.
    " pay the price for reading the sensor directly ; get this party started "
    Smalltalk isMorphic
        ifTrue: [aHand _ World activeHand.
            aHand newMouseFocus: nil;
                 showTemporaryCursor: nil;
                 flushEvents].
    Sensor processEvent: Sensor createMouseEvent.
    ^ rect! !

!Rectangle methodsFor: 'transforming' stamp: 'JMM 10/21/2003 17:28'!
newRectFrom: newRectBlock
    "Track the outline of a new rectangle until mouse button changes.
    newFrameBlock produces each new rectangle from the previous"
    | rect newRect buttonStart buttonNow aHand delay |
    delay _ Delay forMilliseconds: 10.
    buttonStart _ buttonNow _ Sensor anyButtonPressed.
    rect _ self.
    Display border: rect width: 2 rule: Form reverse fillColor: Color gray.
    [buttonNow == buttonStart] whileTrue: 
        [delay wait.
        buttonNow _ Sensor anyButtonPressed.
        newRect _ newRectBlock value: rect.
        newRect = rect ifFalse:
            [Display border: rect width: 2 rule: Form reverse fillColor: Color gray.
            Display border: newRect width: 2 rule: Form reverse fillColor: Color gray.
            rect _ newRect]].
    Display border: rect width: 2 rule: Form reverse fillColor: Color gray.
    " pay the price for reading the sensor directly ; get this party started "
    Smalltalk isMorphic
        ifTrue: [aHand _ World activeHand.
            aHand newMouseFocus: nil;
                 showTemporaryCursor: nil;
                 flushEvents].
    Sensor processEvent: Sensor createMouseEvent.
    ^ rect! !

!Rectangle methodsFor: 'transforming' stamp: 'di 6/11/97 15:11'!
rotateBy: direction centerAt: aPoint
    "Return a copy rotated #right, #left, or #pi about aPoint"
    ^ (origin rotateBy: direction centerAt: aPoint)
        rect: (corner rotateBy: direction centerAt: aPoint)! !

!Rectangle methodsFor: 'transforming'!
scaleBy: scale 
    "Answer a Rectangle scaled by scale, a Point or a scalar."

    ^Rectangle origin: origin * scale corner: corner * scale! !

!Rectangle methodsFor: 'transforming'!
scaleFrom: rect1 to: rect2
    "Produce a rectangle stretched according to the stretch from rect1 to rect2"
    ^ (origin scaleFrom: rect1 to: rect2)
        corner: (corner scaleFrom: rect1 to: rect2)! !

!Rectangle methodsFor: 'transforming' stamp: 'sw 5/21/96'!
squishedWithin: aRectangle
    "Return an adjustment of the receiver that fits within aRectangle by reducing its size, not by changing its origin.  "

    ^ origin corner: (corner min: aRectangle bottomRight)

"(50 @ 50 corner: 160 @ 100) squishedWithin:  (20 @ 10 corner: 90 @ 85)"
! !

!Rectangle methodsFor: 'transforming'!
translateBy: factor 
    "Answer a Rectangle translated by factor, a Point or a scalar."

    ^Rectangle origin: origin + factor corner: corner + factor! !

!Rectangle methodsFor: 'transforming' stamp: 'nk 7/5/2003 08:31'!
translatedAndSquishedToBeWithin: aRectangle
    "Return an adjustment of the receiver that fits within aRectangle by
        - translating it to be within aRectangle if necessary, then
        - reducing its size, if necessary"

    ^ (self translatedToBeWithin: aRectangle) squishedWithin: aRectangle! !


!Rectangle methodsFor: 'printing'!
printOn: aStream 
    "Refer to the comment in Object|printOn:."

    origin printOn: aStream.
    aStream nextPutAll: ' corner: '.
    corner printOn: aStream! !

!Rectangle methodsFor: 'printing' stamp: 'MPW 1/4/1901 08:18'!
propertyListOn: aStream 
    " {x=a; y=b; width=c; height=d} "
    aStream print:'{ x='; write:origin x;
            print:' y='; write:origin y;
            print:' width='; write:self extent x;
            print:' height='; write:self extent y;
            print:'};'.
! !

!Rectangle methodsFor: 'printing'!
storeOn: aStream 
    "printed form is good for storing too"
    self printOn: aStream! !


!Rectangle methodsFor: 'private'!
setOrigin: topLeft corner: bottomRight
    origin _ topLeft.
    corner _ bottomRight! !


!Rectangle methodsFor: 'FMP' stamp: 'RAA 6/1/1999 17:41'!
deltaToEnsureInOrCentered: r extra: aNumber

    | dX dY halfXDiff halfYDiff |
    dX _ dY _ 0.
    halfXDiff _ (r width - self width * aNumber) truncated.
    halfYDiff _ (r height - self height  * aNumber) truncated.
    self left &lt; r left
        ifTrue: [dX _ self left - r left - halfXDiff]
        ifFalse: [self right &gt; r right ifTrue: [dX _ self right - r right + halfXDiff]].
    self top &lt; r top
        ifTrue: [dY _ self top - r top - halfYDiff]
        ifFalse: [self bottom &gt; r bottom ifTrue: [dY _ self bottom - r bottom + halfYDiff]].
    ^dX @ dY
! !


!Rectangle methodsFor: '*nebraska-Morphic-Remote' stamp: 'RAA 7/31/2000 17:25'!
encodeForRemoteCanvas

    | encoded |

    CanvasEncoder at: 2 count:  1.
    encoded := String new: 16.
    encoded putInteger32: origin x asInteger at: 1.
    encoded putInteger32: origin y asInteger at: 5.
    encoded putInteger32: corner x asInteger at: 9.
    encoded putInteger32: corner y asInteger at: 13.

    ^encoded! !

!Rectangle methodsFor: '*nebraska-Morphic-Remote' stamp: 'RAA 7/31/2000 16:39'!
encodeForRemoteCanvasB

    | encoded |

    encoded := Bitmap new: 4.
    encoded at: 1 put: origin x asInteger.
    encoded at: 2 put: origin y asInteger.
    encoded at: 3 put: corner x asInteger.
    encoded at: 4 put: corner y asInteger.

    ^encoded! !


!Rectangle methodsFor: '*morphic-Postscript Canvases' stamp: 'mpw 8/9/1930 08:00'!
encodePostscriptOn:aStream 
    aStream write:self origin; print:' '; write:self extent; print:' '.! !


!Rectangle methodsFor: '*connectors-geometry' stamp: 'nk 6/21/2003 13:14'!
extrapolatedIntersectionsWithLineFrom: start to: end
    | intersections side ex ey delta dx dy |
    intersections _ self intersectionsWithLineFrom: start to: end.
    intersections size = 1 ifFalse: [ ^intersections ].
    side _ self sideNearestTo: intersections anyOne.
    delta _ end - start.
    side == #left ifTrue: [ ex _ self right. ].
    side == #right ifTrue: [ ex _ self left ].
    side == #top ifTrue: [ ey _ self bottom ].
    side == #bottom ifTrue: [ ey _ self top ].

    ex ifNil: [
        delta y isZero ifTrue: [ ex _ start x ] ifFalse: [ 
            dx _ (ey - start y) * delta x / delta y.
            ex _ start x + dx.
        ]
    ].
    ey ifNil: [
        delta x isZero ifTrue: [ ey _ start y ] ifFalse: [ 
            dy _ (ex - start x) * delta y / delta x.
            ey _ start y + dy
        ].
    ].
    intersections add: ex@ey.
    ^intersections! !





!Rectangle methodsFor: '*SelfEvaluatingObject' stamp: 'ab 2/12/2005 19:57'!
isSelfEvaluating
    ^ self class == Rectangle! !


!Rectangle methodsFor: '*BabySRE-connectors-geometry' stamp: 'nk 3/29/2002 22:51'!
intersectionWithLineSegmentFromCenterTo: aPoint 
    "Answer the point, if any, along my border that intersects the  
    line segment between my center and aPoint. Return aPoint if  
    aPoint is inside me or is on my border, else a computed point  
    somewhere along my border."

    | seg |
    (self containsPoint: aPoint)
        ifTrue: [^ aPoint].
    "Answer the set of intersections, if any"
    seg _ LineSegment from: self center to: aPoint.
    self lineSegmentsDo: [ :p1 :p2 | | side int |
        side _ LineSegment from: p1 to: p2.
        int _ side intersectionWith: seg.
        int ifNotNil: [ ^int ].
    ].

    self error: 'no intersection found'! !

!Rectangle methodsFor: '*BabySRE-connectors-geometry' stamp: 'nk 3/29/2002 22:56'!
intersectionsWithLineFrom: start to: end
    "Answer the set of intersections, if any"
    | retval l i |
    retval _ IdentitySet new: 4.
    l _ LineSegment from: start to: end.
    self lineSegmentsDo: [ :p1 :p2 | | s |
        s _ LineSegment from: p1 to: p2.
        i _ s intersectionWith: l.
        i ifNotNil: [ retval add: i ].
    ].
    ^retval! !


!Rectangle methodsFor: '*BabySRE-connectors-testing' stamp: 'nk 2/27/2001 11:12'!
intersectsLineFrom: start to: finish 
    ^ (self topLeft
            to: self topRight
            intersects: start
            to: finish)
        or: [(self topRight
                    to: self bottomRight
                    intersects: start
                    to: finish)
                or: [(self bottomRight
                            to: self bottomLeft
                            intersects: start
                            to: finish)
                        or: [self bottomLeft
                                to: self topLeft
                                intersects: start
                                to: finish]]]! !


!Rectangle methodsFor: '*BabySRE-connectors-rectangle functions' stamp: 'nk 3/29/2002 22:34'!
lineSegmentsDo: aBlock
    "Evaluate aBlock with the receiver's line segments"
    | p |
    aBlock value: origin value: (p _ self topRight).
    aBlock value: p value: corner.
    aBlock value: corner value: (p _ self bottomLeft).
    aBlock value: p value: origin.! !


!Rectangle methodsFor: '*BabySRE-connectors-transforming' stamp: 'nk 3/27/2001 18:19'!
scaleAndTranslateToFitInside: anotherRectangle
    "Answer a Rectangle with the same aspect ratio as me, but that will fit inside
    anotherRectangle."
    | newExtent |
    newExtent _ self extent scaleToNoGreaterThan: anotherRectangle extent.
    ^(Rectangle origin: self origin extent: newExtent) translatedToBeWithin: anotherRectangle.
! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

Rectangle class
    instanceVariableNames: ''!

!Rectangle class methodsFor: 'instance creation' stamp: 'tk 3/9/97'!
center: centerPoint extent: extentPoint 
    "Answer an instance of me whose center is centerPoint and width 
    by height is extentPoint.  "

    ^self origin: centerPoint - (extentPoint//2) extent: extentPoint! !

!Rectangle class methodsFor: 'instance creation' stamp: 'di 12/1/97 10:42'!
encompassing: listOfPoints
    "A number of callers of encompass: should use this method."
    | topLeft bottomRight |
    topLeft _ bottomRight _ nil.
    listOfPoints do:
        [:p | topLeft == nil
            ifTrue: [topLeft _ bottomRight _ p]
            ifFalse: [topLeft _ topLeft min: p.
                    bottomRight _ bottomRight max: p]].
    ^ topLeft corner: bottomRight! !

!Rectangle class methodsFor: 'instance creation'!
fromUser
    "Answer an instance of me that is determined by having the user 
    designate the top left and bottom right corners. The gridding for user 
    selection is 1@1."

    ^self fromUser: 1 @ 1! !

!Rectangle class methodsFor: 'instance creation'!
fromUser: gridPoint
    "Answer a Rectangle that is determined by having the user 
    designate the top left and bottom right corners. 
    The cursor reamins linked with the sensor, but
    the outline is kept gridded."
    | originRect |
    originRect _ Cursor origin showWhile: 
        [((Sensor cursorPoint grid: gridPoint) extent: 0@0) newRectFrom:
            [:f | (Sensor cursorPoint grid: gridPoint) extent: 0@0]].
    ^ Cursor corner showWhile:
        [originRect newRectFrom:
            [:f | f origin corner: (Sensor cursorPoint grid: gridPoint)]]! !

!Rectangle class methodsFor: 'instance creation' stamp: 'md 12/3/2004 00:02'!
left: leftNumber right: rightNumber top: topNumber bottom: bottomNumber 
    "Answer an instance of me whose left, right, top, and bottom coordinates 
    are determined by the arguments."

    ^ self basicNew setOrigin: leftNumber @ topNumber corner: rightNumber @ bottomNumber! !

!Rectangle class methodsFor: 'instance creation' stamp: 'btr 2/14/2003 16:29'!
merging: listOfRects 
    "A number of callers of merge: should use this method."
    | minX minY maxX maxY |
    listOfRects
        do: [:r | minX
                ifNil: [minX _ r topLeft x. minY _ r topLeft y.
                    maxX _ r bottomRight x. maxY _ r bottomRight y]
                ifNotNil: [minX _ minX min: r topLeft x. minY _ minY min: r topLeft y.
                    maxX _ maxX max: r bottomRight x. maxY _ maxY max: r bottomRight y]].
    ^ minX@minY corner: maxX@maxY! !

!Rectangle class methodsFor: 'instance creation' stamp: 'md 12/3/2004 00:04'!
origin: originPoint corner: cornerPoint 
    "Answer an instance of me whose corners (top left and bottom right) are 
    determined by the arguments."

    ^self basicNew setOrigin: originPoint corner: cornerPoint! !

!Rectangle class methodsFor: 'instance creation' stamp: 'md 12/3/2004 00:03'!
origin: originPoint extent: extentPoint 
    "Answer an instance of me whose top left corner is originPoint and width 
    by height is extentPoint."

    ^self basicNew setOrigin: originPoint corner: originPoint + extentPoint! !

!Rectangle class methodsFor: 'instance creation'!
originFromUser: extentPoint 
    "Answer an instance of me that is determined by having the user 
    designate the top left corner. The width and height are determined by 
    extentPoint. The gridding for user selection is 1@1."

    ^self originFromUser: extentPoint grid: 1 @ 1! !

!Rectangle class methodsFor: 'instance creation'!
originFromUser: extentPoint grid: gridPoint 
    "Answer an instance of me that is determined by having the user 
    designate the top left corner. The width and height are determined by 
    extentPoint. The gridding for user selection is scaleFactor. Assumes that 
    the sender has determined an extent that is a proper multiple of 
    scaleFactor."

    ^ Cursor origin showWhile: 
        [((Sensor cursorPoint grid: gridPoint) extent: extentPoint) newRectFrom:
            [:f | (Sensor cursorPoint grid: gridPoint) extent: extentPoint]].
! !
"""

</t>
<t tx="karstenw.20210217133714.1">def asFloatPoint( self ):
    return Point( float(self.x), float(self.y))

def asIntegerPoint( self ):
    return Point( int(self.x), int(self.y))

def corner( aPoint ):
    return Rectangle( self, aPoint )

def extent( self, aPoint ):
    """Answer a Rectangle whose origin is the receiver and whose extent is 
       aPoint. This is one of the infix ways of expressing the creation of a 
       rectangle."""
    return Rectangle.originExtent( self, aPoint )

def isPoint( self ):
    return True

def rect( aPoint ):
    """Answer a Rectangle that encompasses the receiver and aPoint.
       This is the most general infix way to create a rectangle."""
    return Rectangle( min(self, aPoint), max(self, aPoint ))


</t>
<t tx="karstenw.20210217133725.1">def copy( self ):
    return Point( self.x, self.y )

</t>
<t tx="karstenw.20210217134011.1">def sideOf( self, otherPoint ):
    """Returns #left, #right or #center if the otherPoint lies to the left, right 
    or on the line given by the vector from 0@0 to self"""
    side = self.crossProduct( otherPoint )
    side = sign( side )
    sides = ('right', 'center', 'left')
    return sides[side+1]



</t>
<t tx="karstenw.20210217134045.1">def interpolateToAt( self, end, amountDone ):
    """Interpolate between the instance and end after the specified amount has been done (0 - 1)."""
    return self + ((end - self) * amountDone)

def bearingToPoint( self, anotherPoint ):
    """Return the bearing, in degrees, from the receiver to anotherPoint.
       Adapted from Playground, where the ultimate provenance of the algorithm
       was a wild earlier method of Jay Fenton's which I never checked carefully,
       but the thing has always seemed to work."""

    deltaX = anotherPoint.x - self.x
    deltaY = anotherPoint.y - self.x
    
    if abs(deltaX) &lt; 0.001:
        if deltaY &gt; 0:
            return 180.0
        else:
            return 0.0
    
    q = 270
    if deltaX &gt;= 0:
        q = 90
    return q - round( math.degrees(-math.arctan(deltaY / deltaX)) )

def crossProduct( self, aPoint ):
    """Answer a number that is the cross product of the receiver and the 
    argument, aPoint."""
    
    return (self.x * aPoint.y) - (self.y * aPoint.x)


def dist( self, aPoint ):
    """Answer the distance between aPoint and the receiver."""
    dx = aPoint.x - self.x
    dy = aPoint.y - self.y
    return math.sqrt( (dx * dx) + (dy * dy) )

def dotProduct( self, aPoint ):
    """Answer a number that is the dot product of the receiver and the 
    argument, aPoint. That is, the two points are multipled and the 
    coordinates of the result summed."""
    return (self.x * aPoint.x) + (self.y * aPoint.y)

def eightNeighbors( self ):
    return [
        self + Point( 1, 0),
        self + Point( 1, 1),
        self + Point( 0, 1),
        self + Point(-1, 1),
        self + Point(-1, 0),
        self + Point(-1,-1),
        self + Point( 0,-1),
        self + Point( 1,-1)]

def fourNeighbors( self ):
    return [
        self + Point( 1, 0),
        self + Point( 0, 1),
        self + Point(-1, 0),
        self + Point( 0,-1)]

def flipByCenterAt( self, direction, center ):
    """Answer a Point which is flipped according to the direction about the point c.
       Direction must be #vertical or #horizontal."""
    if direction == "vertical":
        return Point( self.x, center.y * 2 - self.y)
    elif direction == "horizontal":
        return Point( center.x * 2 - self.x, self.y )
    # raise error: 'unrecognizable direction'

def grid( self, aPoint ):
    "Answer a Point to the nearest rounded grid modules specified by aPoint."
    newX = self.x + (aPoint.x // 2)
    gridPoint = makepoint( aPoint )
    x = (self.x // gridPoint.x) * gridPoint.x
    y = (self.y // gridPoint.y) * gridPoint.y
    return Point(x,y)

def insideTriangle( self, p1, p2, p3 ):
    """Return true if the receiver is within the triangle defined by the three coordinates.
       Note: This method computes the barycentric coordinates for the receiver and tests those coordinates."""
    p0 = self
    b0 = ((p2.x - p1.x) * (p3.y - p1.y)) - ((p3.x - p1.x) * (p2.y - p1.y))

    if b0.isZero():
        # degenerate
        return False
    
    b0 = ( 1.0 / b0.x, 1.0 / b0.y )
    b1 = (((p2.x - p0.x) * (p3.y - p0.y)) - ((p3.x - p0.x) * (p2.y - p0.y))) * b0


def nearestPointAlongLineFromTo( self, p1, p2 ):
    """Note this will give points beyond the endpoints.
    Streamlined by Gerardo Richarte 11/3/97"""

    if p1.x == p2.x:
        return Point(p1.x, self.y)
    if p1.y == p2.y:
        return Point( self.x, p1.y )
    x1 = float( p1.x )
    y1 = float( p1.y )
    x21 = float(p2.x) - x1
    y21 = float(p2.y) - y1
    t = ((float(self.y) - y1) / x21 + (float(self.x) - x1) / y21) / ( (x21 / y21) + (y21 / x21))
    return Point(x1 + (t * x21)) , (y1 + (t * y21))

def skalarPointOnLine( self, p1, p2, t ):
    """return the point p1 + (t * (p2-p1))
    kw 2021-02-25"""
    if t &gt; 1.0:
        return p2
    elif t &lt; 0.0:
        return p1
    
    dist = p2 - p1
    return p1 + (t * dist)


"""
! !

!Point methodsFor: 'point functions'!
grid: aPoint 
	"Answer a Point to the nearest rounded grid modules specified by aPoint."

	| newX newY |
	newX _ x + (aPoint x // 2) truncateTo: aPoint x.
	newY _ y + (aPoint y // 2) truncateTo: aPoint y.
	^newX @ newY! !

!Point methodsFor: 'point functions' stamp: 'ar 5/22/2001 23:46'!
insideTriangle: p1 with: p2 with: p3
	"Return true if the receiver is within the triangle defined by the three coordinates.
	Note: This method computes the barycentric coordinates for the receiver and tests those coordinates."
	| p0 b0 b1 b2 b3 |
	p0 _ self.
	b0 _ ((p2 x - p1 x) * (p3 y - p1 y)) - ((p3 x - p1 x) * (p2 y - p1 y)).
	b0 isZero ifTrue:[^false]. "degenerate"
	b0 _ 1.0 / b0.
	b1 _ (((p2 x - p0 x) * (p3 y - p0 y)) - ((p3 x - p0 x) * (p2 y - p0 y))) * b0.
	b2 _ (((p3 x - p0 x) * (p1 y - p0 y)) - ((p1 x - p0 x) * (p3 y - p0 y))) * b0.
	b3 _ (((p1 x - p0 x) * (p2 y - p0 y)) - ((p2 x - p0 x) * (p1 y - p0 y))) * b0.
	b1 &lt; 0.0 ifTrue:[^false].
	b2 &lt; 0.0 ifTrue:[^false].
	b3 &lt; 0.0 ifTrue:[^false].
	^true

! !

!Point methodsFor: 'point functions' stamp: 'di 12/1/97 12:40'!
nearestPointOnLineFrom: p1 to: p2
	"This will not give points beyond the endpoints"
	^ (self nearestPointAlongLineFrom: p1 to: p2)
		adhereTo: (p1 rect: p2)! !

!Point methodsFor: 'point functions'!
normal
	"Answer a Point representing the unit vector rotated 90 deg clockwise."

	| n |
	n _ y negated @ x.
	^n / (n x * n x + (n y * n y)) sqrt! !

!Point methodsFor: 'point functions' stamp: 'ar 8/26/2001 22:15'!
normalized
	"Optimized for speed -- ar 8/26/2001"
	| r |
	r _ ((x*x) + (y * y)) sqrt.
	^(x / r) @ (y / r)! !

!Point methodsFor: 'point functions' stamp: 'laza 12/13/1999 11:43'!
octantOf: otherPoint 
	"Return 1..8 indicating relative direction to otherPoint.  
	1=ESE, 2=SSE, ... etc. clockwise to 8=ENE"
	"[Sensor anyButtonPressed] whileFalse: [(Display boundingBox center 
	octantOf: Sensor cursorPoint) printString displayAt: 0@0]"
	| quad moreHoriz |
	(x = otherPoint x and: [y &gt; otherPoint y])
		ifTrue: [^ 6].
	"special case"
	(y = otherPoint y and: [x &lt; otherPoint x])
		ifTrue: [^ 8].
	quad _ self quadrantOf: otherPoint.
	moreHoriz _ (x - otherPoint x) abs &gt;= (y - otherPoint y) abs.
	(quad even eqv: moreHoriz)
		ifTrue: [^ quad * 2]
		ifFalse: [^ quad * 2 - 1]! !

!Point methodsFor: 'point functions' stamp: 'di 12/1/97 12:12'!
onLineFrom: p1 to: p2
	^ self onLineFrom: p1 to: p2 within: 2! !

!Point methodsFor: 'point functions' stamp: 'jm 2/24/98 08:34'!
onLineFrom: p1 to: p2 within: epsilon
	"Answer true if the receiver lies on the given line segment between p1 and p2 within a small epsilon."

	"is this point within the box spanning p1 and p2 expanded by epsilon? (optimized)"
	p1 x &lt; p2 x
		ifTrue: [
			((x &lt; (p1 x - epsilon)) or: [x &gt; (p2 x + epsilon)]) ifTrue: [^ false]]
		ifFalse: [
			((x &lt; (p2 x - epsilon)) or: [x &gt; (p1 x + epsilon)]) ifTrue: [^ false]].
	p1 y &lt; p2 y
		ifTrue: [
			((y &lt; (p1 y - epsilon)) or: [y &gt; (p2 y + epsilon)]) ifTrue: [^ false]]
		ifFalse: [
			((y &lt; (p2 y - epsilon)) or: [y &gt; (p1 y + epsilon)]) ifTrue: [^ false]].

	"it's in the box; is it on the line?"
	^ (self dist: (self nearestPointAlongLineFrom: p1 to: p2)) &lt;= epsilon! !

!Point methodsFor: 'point functions' stamp: '6/9/97 14:51 di'!
quadrantOf: otherPoint
	"Return 1..4 indicating relative direction to otherPoint.
	1 is downRight, 2=downLeft, 3=upLeft, 4=upRight"
	^ x &lt;= otherPoint x
		ifTrue: [y &lt; otherPoint y ifTrue: [1] ifFalse: [4]]
		ifFalse: [y &lt;= otherPoint y ifTrue: [2] ifFalse: [3]]
"
[Sensor anyButtonPressed] whileFalse:
	[(Display boundingBox center quadrantOf: Sensor cursorPoint) printString displayAt: 0@0]
"! !

!Point methodsFor: 'point functions' stamp: 'di 6/11/97 15:12'!
rotateBy: direction centerAt: c
	"Answer a Point which is rotated according to direction, about the point c.
	Direction must be one of #right (CW), #left (CCW) or #pi (180 degrees)."
	| offset |
	offset _ self - c.
	direction == #right ifTrue: [^ (offset y negated @ offset x) + c].
	direction == #left ifTrue: [^ (offset y @ offset x negated) + c].
	direction == #pi ifTrue: [^ c - offset].
	self error: 'unrecognizable direction'! !

!Point methodsFor: 'point functions' stamp: 'ar 4/18/1999 05:17'!
sortsBefore: otherPoint
	"Return true if the receiver sorts before the other point"
	^y = otherPoint y
		ifTrue:[x &lt;= otherPoint x]
		ifFalse:[y &lt;= otherPoint y]! !

!Point methodsFor: 'point functions' stamp: 'ar 5/23/2001 21:29'!
squaredDistanceTo: aPoint
	"Answer the distance between aPoint and the receiver."
	| delta |
	delta _ aPoint - self.
	^delta dotProduct: delta! !

!Point methodsFor: 'point functions' stamp: 'ar 11/12/1998 01:44'!
transposed
	^y@x! !

"""
</t>
<t tx="karstenw.20210217134139.1">
def degrees( self ):
    if self.x == 0:
        if self.y &gt;= 0:
            return 90.0
        else:
            return 270.0
    else:
        tangente = float(self.y) / float(self.x)
        theta = math.atan( tangente )
        if self.x &gt;= 0:
            if self.y &gt;= 0:
                return math.degrees( theta )
            else:
                return 360.0 + math.degrees( theta )
        else:
            return 180.0 + math.degrees( theta )


def degreesWith( self, aPoint ):
    """Answer the angle the receiver makes with origin in degrees. right is 0; down is 90."""
    pass


def r( self ):
    pass


def theta( self ):
    pass



"""
!Point methodsFor: 'polar coordinates' stamp: 'di 6/12/97 12:18'!
degrees
	"Answer the angle the receiver makes with origin in degrees. right is 0; down is 90."
	| tan theta |
	x = 0
		ifTrue: [y &gt;= 0
				ifTrue: [^ 90.0]
				ifFalse: [^ 270.0]]
		ifFalse: 
			[tan _ y asFloat / x asFloat.
			theta _ tan arcTan.
			x &gt;= 0
				ifTrue: [y &gt;= 0
						ifTrue: [^ theta radiansToDegrees]
						ifFalse: [^ 360.0 + theta radiansToDegrees]]
				ifFalse: [^ 180.0 + theta radiansToDegrees]]! !

!Point methodsFor: 'polar coordinates' stamp: 'kw 2/28/2004 18:26'!
degrees: aPoint
	"Answer the angle the receiver makes with origin in degrees. right is 0; down is 90."
	| tan theta |
	(x = aPoint x)
		ifTrue: [(y &gt;= aPoint y)
				ifTrue: [^ 0.0]
				ifFalse: [^ 180.0]]
		ifFalse: 
			[tan _ (y - aPoint y) asFloat / (x - aPoint x)  asFloat.
			theta _ tan arcTan.
			(x &gt;= aPoint x)
				ifTrue: [(y &gt;= aPoint y)
						ifTrue: [^ theta radiansToDegrees]
						ifFalse: [^ 360.0 + theta radiansToDegrees]]
				ifFalse: [^ 180.0 + theta radiansToDegrees]]! !

!Point methodsFor: 'polar coordinates'!
r
	"Answer the receiver's radius in polar coordinate system."

	^(self dotProduct: self) sqrt! !

!Point methodsFor: 'polar coordinates'!
theta
	"Answer the angle the receiver makes with origin in radians. right is 0; 
	down is 90."

	| tan theta |
	x = 0
		ifTrue: [y &gt;= 0
				ifTrue: [^1.5708"90.0 degreesToRadians"]
				ifFalse: [^4.71239"270.0 degreesToRadians"]]
		ifFalse: 
			[tan _ y asFloat / x asFloat.
			theta _ tan arcTan.
			x &gt;= 0
				ifTrue: [y &gt;= 0
						ifTrue: [^theta]
						ifFalse: [^360.0 degreesToRadians + theta]]
				ifFalse: [^180.0 degreesToRadians + theta]]! !

"""
</t>
<t tx="karstenw.20210217134254.1">

"""
!Point methodsFor: 'private' stamp: 'ar 4/4/1999 00:40'!
bitShiftPoint: bits
	x _ x bitShift: bits.
	y _ y bitShift: bits.! !

!Point methodsFor: 'private' stamp: 'tk 10/4/2001 16:16'!
setR: rho degrees: degrees 

	| radians |
	radians _ degrees asFloat degreesToRadians.
	x _ rho asFloat * radians cos.
	y _ rho asFloat * radians sin.! !

!Point methodsFor: 'private' stamp: 'sw 3/21/2000 13:24'!
setX: xValue setY: yValue

	x _ xValue.
	y _ yValue! !



"""

</t>
<t tx="karstenw.20210217134318.1">
"""
!Point methodsFor: 'transforming' stamp: 'di 4/30/1998 11:16'!
adhereTo: aRectangle
	"If the receiver lies outside aRectangle, return the nearest point on the boundary of the rectangle, otherwise return self."

	(aRectangle containsPoint: self) ifTrue: [^ self].
	^ ((x max: aRectangle left) min: aRectangle right)
		@ ((y max: aRectangle top) min: aRectangle bottom)! !

!Point methodsFor: 'transforming' stamp: 'ar 8/26/2001 22:14'!
negated
	"Answer a point whose x and y coordinates are the negatives of those of the receiver.  6/6/96 sw"
	"Optimized for speed -- ar 8/26/2001"
	^ (0 - x) @ (0 - y)! !

!Point methodsFor: 'transforming'!
rotateBy: angle about: center
	"Even though Point.theta is measured CW, this rotates with the more conventional CCW interpretateion of angle."

	| p r theta |
	p _ self - center.
	r _ p r.
	theta _ angle asFloat - p theta.
	^ (center x asFloat + (r * theta cos)) @
	  (center y asFloat - (r * theta sin))! !

!Point methodsFor: 'transforming'!
scaleBy: factor 
	"Answer a Point scaled by factor (an instance of Point)."

	^(factor x * x) @ (factor y * y)! !

!Point methodsFor: 'transforming' stamp: 'di 12/4/97 14:34'!
scaleFrom: rect1 to: rect2
	"Produce a point stretched according to the stretch from rect1 to rect2"
	^ rect2 topLeft + (((x-rect1 left) * rect2 width // rect1 width)
					@ ((y-rect1 top) * rect2 height // rect1 height))! !

!Point methodsFor: 'transforming'!
translateBy: delta 
	"Answer a Point translated by delta (an instance of Point)."

	^(delta x + x) @ (delta y + y)! !

"""

</t>
<t tx="karstenw.20210217134349.1">
"""
!Point methodsFor: 'truncation and round off' stamp: 'jm 6/3/1998 12:21'!
rounded
	"Answer a Point that is the receiver's x and y rounded. Answer the receiver if its coordinates are already integral."

	(x isInteger and: [y isInteger]) ifTrue: [^ self].
	^ x rounded @ y rounded
! !

!Point methodsFor: 'truncation and round off'!
truncateTo: grid
	"Answer a Point that is the receiver's x and y truncated to grid x and 
	grid y."
	| gridPoint |
	gridPoint _ grid asPoint.
	^(x truncateTo: gridPoint x) @ (y truncateTo: gridPoint y)! !

!Point methodsFor: 'truncation and round off' stamp: 'jm 5/29/1998 15:53'!
truncated
	"Answer a Point whose x and y coordinates are integers. Answer the receiver if its coordinates are already integral."

	(x isInteger and: [y isInteger]) ifTrue: [^ self].
	^ x truncated @ y truncated
! !


"""
</t>
<t tx="karstenw.20210217134419.1">
"""
!Point methodsFor: 'testing' stamp: 'ar 10/29/2000 19:02'!
isZero
	^x isZero and:[y isZero]! !


!Point methodsFor: '*ICal' stamp: 'pmm 10/9/2005 11:42'!
asArray
	^Array with: self x with: self y! !


!Point methodsFor: '*DrGeoII-point functions' stamp: 'HilaireFernandes 1/3/2006 14:06'!
reflexionBy: aPoint direction: aDirection
"the reflected point according to the axe defined by aPoint and aDirection"
	^ ((self - aPoint) vectorReflexionBy: aDirection) + aPoint! !

!Point methodsFor: '*DrGeoII-point functions' stamp: 'HilaireFernandes 2/7/2006 21:56'!
rotateVector: anAngle
|cosa sina|
	cosa := anAngle cos.
	sina := anAngle sin.
	^ (x * cosa - (y * sina))@(x * sina + (y * cosa))! !

!Point methodsFor: '*DrGeoII-point functions' stamp: 'HilaireFernandes 1/3/2006 13:47'!
vectorReflexionBy: aDirection
"the reflected vector according to the axe defined by aPoint and aVector"
|unit normal|
	unit := aDirection normalized.
	normal := unit normal.
	^((self dotProduct: unit) * unit) - ((self dotProduct: normal) * normal)
! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

Point class
	instanceVariableNames: ''!

!Point class methodsFor: 'instance creation' stamp: 'sw 9/20/97 15:34'!
fromUser
	Sensor waitNoButton.
	Cursor crossHair show.
	Sensor waitButton.
	Cursor normal show.
	^ Sensor cursorPoint

"Point fromUser"! !

!Point class methodsFor: 'instance creation' stamp: 'md 12/2/2004 23:44'!
r: rho degrees: degrees
	"Answer an instance of me with polar coordinates rho and theta."

	^self basicNew setR: rho degrees: degrees! !

!Point class methodsFor: 'instance creation' stamp: 'md 12/2/2004 23:44'!
x: xInteger y: yInteger 
	"Answer an instance of me with coordinates xInteger and yInteger."

	^self basicNew setX: xInteger setY: yInteger! !
"""
</t>
<t tx="karstenw.20210225165613.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20210225165643.1"></t>
<t tx="karstenw.20210225165700.1">

import sys
import os
import math

import pdb


# __all__ = ['Point', 'Rectangle']


</t>
<t tx="karstenw.20210225165727.1">class BitBlt(object):
    
    @others
</t>
<t tx="karstenw.20210225165727.10">@
!BitBlt methodsFor: 'copying'!
copy: destRectangle from: sourcePt in: srcForm
	| destOrigin |
	sourceForm _ srcForm.
	halftoneForm _ nil.
	combinationRule _ 3.  "store"
	destOrigin _ destRectangle origin.
	destX _ destOrigin x.
	destY _ destOrigin y.
	sourceX _ sourcePt x.
	sourceY _ sourcePt y.
	width _ destRectangle width.
	height _ destRectangle height.
	self copyBits! !

!BitBlt methodsFor: 'copying' stamp: 'ar 5/14/2001 23:32'!
copy: destRectangle from: sourcePt in: srcForm fillColor: hf rule: rule
	"Specify a Color to fill, not a Form. 6/18/96 tk"  
	| destOrigin |
	sourceForm _ srcForm.
	self fillColor: hf.	"sets halftoneForm"
	combinationRule _ rule.
	destOrigin _ destRectangle origin.
	destX _ destOrigin x.
	destY _ destOrigin y.
	sourceX _ sourcePt x.
	sourceY _ sourcePt y.
	width _ destRectangle width.
	height _ destRectangle height.
	srcForm == nil ifFalse:
		[colorMap _ srcForm colormapIfNeededFor: destForm].
	^ self copyBits! !

!BitBlt methodsFor: 'copying'!
copy: destRectangle from: sourcePt in: srcForm halftoneForm: hf rule: rule 
	| destOrigin |
	sourceForm _ srcForm.
	self fillColor: hf.		"sets halftoneForm"
	combinationRule _ rule.
	destOrigin _ destRectangle origin.
	destX _ destOrigin x.
	destY _ destOrigin y.
	sourceX _ sourcePt x.
	sourceY _ sourcePt y.
	width _ destRectangle width.
	height _ destRectangle height.
	self copyBits! !

!BitBlt methodsFor: 'copying' stamp: 'nk 4/17/2004 19:41'!
copyBits
	"Primitive. Perform the movement of bits from the source form to the 
	destination form. Fail if any variables are not of the right type (Integer, 
	Float, or Form) or if the combination rule is not implemented. 
	In addition to the original 16 combination rules, this BitBlt supports
	16	fail (to simulate paint)
	17	fail (to simulate mask)
	18	sourceWord + destinationWord
	19	sourceWord - destinationWord
	20	rgbAdd: sourceWord with: destinationWord
	21	rgbSub: sourceWord with: destinationWord
	22	rgbDiff: sourceWord with: destinationWord
	23	tallyIntoMap: destinationWord
	24	alphaBlend: sourceWord with: destinationWord
	25	pixPaint: sourceWord with: destinationWord
	26	pixMask: sourceWord with: destinationWord
	27	rgbMax: sourceWord with: destinationWord
	28	rgbMin: sourceWord with: destinationWord
	29	rgbMin: sourceWord bitInvert32 with: destinationWord
"
	&lt;primitive: 'primitiveCopyBits' module: 'BitBltPlugin'&gt;

	"Check for compressed source, destination or halftone forms"
	(combinationRule &gt;= 30 and: [combinationRule &lt;= 31]) ifTrue:
		["No alpha specified -- re-run with alpha = 1.0"
		^ self copyBitsTranslucent: 255].
	((sourceForm isForm) and: [sourceForm unhibernate])
		ifTrue: [^ self copyBits].
	((destForm isForm) and: [destForm unhibernate])
		ifTrue: [^ self copyBits].
	((halftoneForm isForm) and: [halftoneForm unhibernate])
		ifTrue: [^ self copyBits].

	"Check for unimplmented rules"
	combinationRule = Form oldPaint ifTrue: [^ self paintBits].
	combinationRule = Form oldErase1bitShape ifTrue: [^ self eraseBits].

	"Check if BitBlt doesn't support full color maps"
	(colorMap notNil and:[colorMap isColormap]) ifTrue:[
		colorMap _ colorMap colors.
		^self copyBits].
	"Check if clipping gots us way out of range"
	self clipRange ifTrue:[^self copyBits].

	self error: 'Bad BitBlt arg (Fraction?); proceed to convert.'.
	"Convert all numeric parameters to integers and try again."
	destX _ destX asInteger.
	destY _ destY asInteger.
	width _ width asInteger.
	height _ height asInteger.
	sourceX _ sourceX asInteger.
	sourceY _ sourceY asInteger.
	clipX _ clipX asInteger.
	clipY _ clipY asInteger.
	clipWidth _ clipWidth asInteger.
	clipHeight _ clipHeight asInteger.
	^ self copyBitsAgain! !

!BitBlt methodsFor: 'copying' stamp: 'ar 2/13/2001 21:12'!
copyBitsSimulated
	^Smalltalk at: #BitBltSimulation ifPresent:[:bb| bb copyBitsFrom: self].! !

!BitBlt methodsFor: 'copying' stamp: 'nk 4/17/2004 19:42'!
copyBitsTranslucent: factor
	"This entry point to BitBlt supplies an extra argument to specify translucency
	for operations 30 and 31.  The argument must be an integer between 0 and 255."

	&lt;primitive: 'primitiveCopyBits' module: 'BitBltPlugin'&gt;

	"Check for compressed source, destination or halftone forms"
	((sourceForm isForm) and: [sourceForm unhibernate])
		ifTrue: [^ self copyBitsTranslucent: factor].
	((destForm isForm) and: [destForm unhibernate])
		ifTrue: [^ self copyBitsTranslucent: factor].
	((halftoneForm isForm) and: [halftoneForm unhibernate])
		ifTrue: [^ self copyBitsTranslucent: factor].

	self primitiveFailed  "Later do nicer error recovery -- share copyBits recovery"! !

!BitBlt methodsFor: 'copying' stamp: 'ar 5/14/2001 23:32'!
copyForm: srcForm to: destPt rule: rule
	^ self copyForm: srcForm to: destPt rule: rule
		colorMap: (srcForm colormapIfNeededFor: destForm)! !

!BitBlt methodsFor: 'copying'!
copyForm: srcForm to: destPt rule: rule color: color
	sourceForm _ srcForm.
	halftoneForm _ color.
	combinationRule _ rule.
	destX _ destPt x + sourceForm offset x.
	destY _ destPt y + sourceForm offset y.
	sourceX _ 0.
	sourceY _ 0.
	width _ sourceForm width.
	height _ sourceForm height.
	self copyBits! !

!BitBlt methodsFor: 'copying' stamp: 'di 7/17/97 10:04'!
copyForm: srcForm to: destPt rule: rule colorMap: map
	sourceForm _ srcForm.
	halftoneForm _ nil.
	combinationRule _ rule.
	destX _ destPt x + sourceForm offset x.
	destY _ destPt y + sourceForm offset y.
	sourceX _ 0.
	sourceY _ 0.
	width _ sourceForm width.
	height _ sourceForm height.
	colorMap _ map.
	self copyBits! !

!BitBlt methodsFor: 'copying'!
copyForm: srcForm to: destPt rule: rule fillColor: color
	sourceForm _ srcForm.
	self fillColor: color.	"sets halftoneForm"
	combinationRule _ rule.
	destX _ destPt x + sourceForm offset x.
	destY _ destPt y + sourceForm offset y.
	sourceX _ 0.
	sourceY _ 0.
	width _ sourceForm width.
	height _ sourceForm height.
	self copyBits! !

!BitBlt methodsFor: 'copying' stamp: 'ar 5/14/2001 23:32'!
copyFrom: sourceRectangle in: srcForm to: destPt
	| sourceOrigin |
	sourceForm _ srcForm.
	halftoneForm _ nil.
	combinationRule _ 3.  "store"
	destX _ destPt x.
	destY _ destPt y.
	sourceOrigin _ sourceRectangle origin.
	sourceX _ sourceOrigin x.
	sourceY _ sourceOrigin y.
	width _ sourceRectangle width.
	height _ sourceRectangle height.
	colorMap _ srcForm colormapIfNeededFor: destForm.
	self copyBits! !

!BitBlt methodsFor: 'copying' stamp: 'yo 5/20/2004 14:30'!
displayString: aString from: startIndex to: stopIndex at: aPoint strikeFont: font kern: kernDelta

	destY _ aPoint y.
	destX _ aPoint x.

	"the following are not really needed, but theBitBlt primitive will fail if not set"
	sourceX ifNil: [sourceX _ 100].
	width ifNil: [width _ 100].

	self primDisplayString: aString from: startIndex to: stopIndex
			map: font characterToGlyphMap xTable: font xTable
			kern: kernDelta.
	^ destX@destY.
! !

!BitBlt methodsFor: 'copying'!
fill: destRect fillColor: grayForm rule: rule
	"Fill with a Color, not a Form. 6/18/96 tk"
	sourceForm _ nil.
	self fillColor: grayForm.		"sets halftoneForm"
	combinationRule _ rule.
	destX _ destRect left.
	destY _ destRect top.
	sourceX _ 0.
	sourceY _ 0.
	width _ destRect width.
	height _ destRect height.
	self copyBits! !

!BitBlt methodsFor: 'copying' stamp: 'ar 3/1/2004 13:49'!
pixelAt: aPoint
	"Assumes this BitBlt has been set up specially (see the init message,
	BitBlt bitPeekerFromForm:.  Returns the pixel at aPoint."
	sourceX _ aPoint x.
	sourceY _ aPoint y.
	destForm unhibernate. "before poking"
	destForm bits at: 1 put: 0.  "Just to be sure"
	self copyBits.
	^ destForm bits at: 1! !

!BitBlt methodsFor: 'copying' stamp: 'ar 3/1/2004 13:49'!
pixelAt: aPoint put: pixelValue
	"Assumes this BitBlt has been set up specially (see the init message,
	BitBlt bitPokerToForm:.  Overwrites the pixel at aPoint."
	destX _ aPoint x.
	destY _ aPoint y.
	sourceForm unhibernate. "before poking"
	sourceForm bits at: 1 put: pixelValue.
	self copyBits
"
| bb |
bb _ (BitBlt bitPokerToForm: Display).
[Sensor anyButtonPressed] whileFalse:
	[bb pixelAt: Sensor cursorPoint put: 55]
"! !
</t>
<t tx="karstenw.20210225165727.11">@
!BitBlt methodsFor: 'line drawing'!
drawFrom: startPoint to: stopPoint 
	
	 ^ self drawFrom: startPoint to: stopPoint withFirstPoint: true! !

!BitBlt methodsFor: 'line drawing' stamp: '6/8/97 15:41 di'!
drawFrom: startPoint to: stopPoint withFirstPoint: drawFirstPoint
	"Draw a line whose end points are startPoint and stopPoint.
	The line is formed by repeatedly calling copyBits at every
	point along the line.  If drawFirstPoint is false, then omit
	the first point so as not to overstrike at line junctions."
	| offset point1 point2 forwards |
	"Always draw down, or at least left-to-right"
	forwards _ (startPoint y = stopPoint y and: [startPoint x &lt; stopPoint x])
				or: [startPoint y &lt; stopPoint y].
	forwards
		ifTrue: [point1 _ startPoint. point2 _ stopPoint]
		ifFalse: [point1 _ stopPoint. point2 _ startPoint].
	sourceForm == nil ifTrue:
		[destX _ point1 x.
		destY _ point1 y]
		ifFalse:
		[width _ sourceForm width.
		height _ sourceForm height.
		offset _ sourceForm offset.
		destX _ (point1 x + offset x) rounded.
		destY _ (point1 y + offset y) rounded].

	"Note that if not forwards, then the first point is the last and vice versa.
	We agree to always paint stopPoint, and to optionally paint startPoint."
	(drawFirstPoint or: [forwards == false  "ie this is stopPoint"])
		ifTrue: [self copyBits].
	self drawLoopX: (point2 x - point1 x) rounded 
				  Y: (point2 y - point1 y) rounded.
	(drawFirstPoint or: [forwards  "ie this is stopPoint"])
		ifTrue: [self copyBits].
! !

!BitBlt methodsFor: 'line drawing' stamp: 'ar 2/2/2001 15:09'!
drawLoopX: xDelta Y: yDelta 
	"Primitive. Implements the Bresenham plotting algorithm (IBM Systems
	Journal, Vol. 4 No. 1, 1965). It chooses a principal direction, and
	maintains a potential, P. When P's sign changes, it is time to move in
	the minor direction as well. This particular version does not write the
	first and last points, so that these can be called for as needed in client code.
	Optional. See Object documentation whatIsAPrimitive."
	| dx dy px py P |
	&lt;primitive: 'primitiveDrawLoop' module: 'BitBltPlugin'&gt;
	dx _ xDelta sign.
	dy _ yDelta sign.
	px _ yDelta abs.
	py _ xDelta abs.
	"self copyBits."
	py &gt; px
		ifTrue: 
			["more horizontal"
			P _ py // 2.
			1 to: py do: 
				[:i |
				destX _ destX + dx.
				(P _ P - px) &lt; 0 ifTrue: 
						[destY _ destY + dy.
						P _ P + py].
				i &lt; py ifTrue: [self copyBits]]]
		ifFalse: 
			["more vertical"
			P _ px // 2.
			1 to: px do:
				[:i |
				destY _ destY + dy.
				(P _ P - py) &lt; 0 ifTrue: 
						[destX _ destX + dx.
						P _ P + px].
				i &lt; px ifTrue: [self copyBits]]]! !

</t>
<t tx="karstenw.20210225165727.12">@
!BitBlt methodsFor: 'private' stamp: 'hg 6/27/2000 12:27'!
cachedFontColormapFrom: sourceDepth to: destDepth

	| srcIndex map |
	CachedFontColorMaps class == Array 
		ifFalse: [CachedFontColorMaps _ (1 to: 9) collect: [:i | Array new: 32]].
	srcIndex _ sourceDepth.
	sourceDepth &gt; 8 ifTrue: [srcIndex _ 9].
	(map _ (CachedFontColorMaps at: srcIndex) at: destDepth) ~~ nil ifTrue: [^ map].

	map _ (Color cachedColormapFrom: sourceDepth to: destDepth) copy.
	(CachedFontColorMaps at: srcIndex) at: destDepth put: map.
	^ map
! !

!BitBlt methodsFor: 'private' stamp: 'ar 3/8/2003 00:34'!
clipRange
	"clip and adjust source origin and extent appropriately"
	"first in x"
	| sx sy dx dy bbW bbH |
	"fill in the lazy state if needed"
	destX ifNil:[destX := 0].
	destY ifNil:[destY := 0].
	width ifNil:[width := destForm width].
	height ifNil:[height := destForm height].
	sourceX ifNil:[sourceX := 0].
	sourceY ifNil:[sourceY := 0].
	clipX ifNil:[clipX := 0].
	clipY ifNil:[clipY := 0].
	clipWidth ifNil:[clipWidth := destForm width].
	clipHeight ifNil:[clipHeight := destForm height].

	destX &gt;= clipX
		ifTrue: [sx _ sourceX.
				dx _ destX.
				bbW _ width]
		ifFalse: [sx _ sourceX + (clipX - destX).
				bbW _ width - (clipX - destX).
				dx _ clipX].
	(dx + bbW) &gt; (clipX + clipWidth)
		ifTrue: [bbW _ bbW - ((dx + bbW) - (clipX + clipWidth))].
	"then in y"
	destY &gt;= clipY
		ifTrue: [sy _ sourceY.
				dy _ destY.
				bbH _ height]
		ifFalse: [sy _ sourceY + clipY - destY.
				bbH _ height - (clipY - destY).
				dy _ clipY].
	(dy + bbH) &gt; (clipY + clipHeight)
		ifTrue: [bbH _ bbH - ((dy + bbH) - (clipY + clipHeight))].
	sourceForm ifNotNil:[
		sx &lt; 0
			ifTrue: [dx _ dx - sx.
					bbW _ bbW + sx.
					sx _ 0].
		sx + bbW &gt; sourceForm width
			ifTrue: [bbW _ bbW - (sx + bbW - sourceForm width)].
		sy &lt; 0
			ifTrue: [dy _ dy - sy.
					bbH _ bbH + sy.
					sy _ 0].
		sy + bbH &gt; sourceForm height
			ifTrue: [bbH _ bbH - (sy + bbH - sourceForm height)].
	].
	(bbW &lt;= 0 or:[bbH &lt;= 0]) ifTrue:[
		sourceX := sourceY := destX := destY := clipX := clipY := width := height := 0.
		^true].
	(sx = sourceX 
		and:[sy = sourceY 
		and:[dx = destX 
		and:[dy = destY 
		and:[bbW = width 
		and:[bbH = height]]]]]) ifTrue:[^false].
	sourceX := sx.
	sourceY := sy.
	destX := dx.
	destY := dy.
	width := bbW.
	height := bbH.
	^true! !

!BitBlt methodsFor: 'private' stamp: 'ar 2/2/2001 15:09'!
copyBitsAgain
	"Primitive. See BitBlt|copyBits, also a Primitive. Essential. See Object
	documentation whatIsAPrimitive."

	&lt;primitive: 'primitiveCopyBits' module: 'BitBltPlugin'&gt;
	self primitiveFailed! !

!BitBlt methodsFor: 'private' stamp: 'ar 10/25/1998 17:30'!
copyBitsFrom: x0 to: x1 at: y
	destX _ x0.
	destY _ y.
	sourceX _ x0.
	width _ (x1 - x0).
	self copyBits.! !

!BitBlt methodsFor: 'private'!
eraseBits
	"Perform the erase operation, which puts 0's in the destination
	wherever the source (which is assumed to be just 1 bit deep)
	has a 1.  This requires the colorMap to be set in order to AND
	all 1's into the destFrom pixels regardless of their size."
	| oldMask oldMap |
	oldMask _ halftoneForm.
	halftoneForm _ nil.
	oldMap _ colorMap.
	self colorMap: (Bitmap with: 0 with: 16rFFFFFFFF).
	combinationRule _ Form erase.
	self copyBits. 		"Erase the dest wherever the source is 1"
	halftoneForm _ oldMask.	"already converted to a Bitmap"
	colorMap _ oldMap! !

!BitBlt methodsFor: 'private' stamp: 'ar 5/26/2000 16:38'!
getPluginName
	"Private. Return the name of the plugin representing BitBlt.
	Used for dynamically switching between different BB representations only."
	^'BitBltPlugin'! !

!BitBlt methodsFor: 'private' stamp: 'ar 5/14/2001 23:43'!
installStrikeFont: aStrikeFont foregroundColor: foregroundColor backgroundColor: backgroundColor
	| lastSourceDepth |
	sourceForm ifNotNil:[lastSourceDepth _ sourceForm depth].
	sourceForm _ aStrikeFont glyphs.
	(colorMap notNil and:[lastSourceDepth = sourceForm depth]) ifFalse:
		["Set up color map for a different source depth (color font)"
		"Uses caching for reasonable efficiency"
		colorMap _ self cachedFontColormapFrom: sourceForm depth to: destForm depth.
		colorMap at: 1 put: (destForm pixelValueFor: backgroundColor)].
	sourceForm depth = 1 ifTrue:
		[colorMap at: 2 put: (destForm pixelValueFor: foregroundColor).
		"Ignore any halftone pattern since we use a color map approach here"
		halftoneForm _ nil].
	sourceY _ 0.
	height _ aStrikeFont height.
! !

!BitBlt methodsFor: 'private' stamp: 'yo 1/8/2005 09:12'!
installTTCFont: aTTCFont foregroundColor: foregroundColor backgroundColor: backgroundColor
	"Set up the parameters.  Since the glyphs in a TTCFont is 32bit depth form, it tries to use rule=34 to get better AA result if possible."

	((aTTCFont depth = 32)) ifTrue: [
		destForm depth &lt;= 8 ifTrue: [
			self colorMap: (self cachedFontColormapFrom: aTTCFont depth to: destForm depth).
			self combinationRule: Form paint.
		] ifFalse: [
			self colorMap: nil.
			self combinationRule: 34.
		].
		halftoneForm _ nil.
		sourceY _ 0.
		height _ aTTCFont height.
	].
! !

!BitBlt methodsFor: 'private'!
paintBits
	"Perform the paint operation, which requires two calls to BitBlt."
	| color oldMap saveRule |
	sourceForm depth = 1 ifFalse: 
		[^ self halt: 'paint operation is only defined for 1-bit deep sourceForms'].
	saveRule _ combinationRule.
	color _ halftoneForm.  halftoneForm _ nil.
	oldMap _ colorMap.
	"Map 1's to ALL ones, not just one"
	self colorMap: (Bitmap with: 0 with: 16rFFFFFFFF).
	combinationRule _ Form erase.
	self copyBits. 		"Erase the dest wherever the source is 1"
	halftoneForm _ color.
	combinationRule _ Form under.
	self copyBits.	"then OR, with whatever color, into the hole"
	colorMap _ oldMap.
	combinationRule _ saveRule

" | dot |
dot _ Form dotOfSize: 32.
((BitBlt destForm: Display
		sourceForm: dot
		fillColor: Color lightGray
		combinationRule: Form paint
		destOrigin: Sensor cursorPoint
		sourceOrigin: 0@0
		extent: dot extent
		clipRect: Display boundingBox)
		colorMap: (Bitmap with: 0 with: 16rFFFFFFFF)) copyBits"! !

!BitBlt methodsFor: 'private' stamp: 'yo 3/11/2005 14:49'!
primDisplayString: aString from: startIndex to: stopIndex map: glyphMap xTable: xTable kern: kernDelta
	| ascii |
	&lt;primitive:'primitiveDisplayString' module:'BitBltPlugin'&gt;
	startIndex to: stopIndex do:[:charIndex|
		ascii _ (aString at: charIndex) asciiValue.
		sourceX _ xTable at: ascii + 1.
		width _ (xTable at: ascii + 2) - sourceX.
		self copyBits.
		destX _ destX + width + kernDelta.
	].! !

!BitBlt methodsFor: 'private'!
setDestForm: df
	| bb |
	bb _ df boundingBox.
	destForm _ df.
	clipX _ bb left.
	clipY _ bb top.
	clipWidth _ bb width.
	clipHeight _ bb height! !

!BitBlt methodsFor: 'private' stamp: 'ar 5/14/2001 23:32'!
setDestForm: df sourceForm: sf fillColor: hf combinationRule: cr destOrigin: destOrigin sourceOrigin: sourceOrigin extent: extent clipRect: clipRect

	| aPoint |
	destForm _ df.
	sourceForm _ sf.
	self fillColor: hf.	"sets halftoneForm"
	combinationRule _ cr.
	destX _ destOrigin x.
	destY _ destOrigin y.
	sourceX _ sourceOrigin x.
	sourceY _ sourceOrigin y.
	width _ extent x.
	height _ extent y.
	aPoint _ clipRect origin.
	clipX _ aPoint x.
	clipY _ aPoint y.
	aPoint _ clipRect corner.
	clipWidth _ aPoint x - clipX.
	clipHeight _ aPoint y - clipY.
	sourceForm == nil ifFalse:
		[colorMap _ sourceForm colormapIfNeededFor: destForm]! !

</t>
<t tx="karstenw.20210225165727.13">def __init__(self):
    # instanceVariableNames: 'destForm sourceForm halftoneForm combinationRule destX destY width height sourceX sourceY clipX clipY clipWidth clipHeight colorMap'
    # classVariableNames: 'CachedFontColorMaps'
    pass


</t>
<t tx="karstenw.20210225165727.2">"""
I represent a block transfer (BLT) of pixels into a rectangle (destX, destY, width, height) of the destinationForm.  The source of pixels may be a similar rectangle (at sourceX, sourceY) in the sourceForm, or a constant color, currently called halftoneForm.  If both are specified, their pixel values are combined with a logical AND function prior to transfer.  In any case, the pixels from the source are combined with those of the destination by as specified by the combinationRule.

The combination rule whose value is 0 through 15 programs the transfer to produce 1 or 0 according to its 4-bit representation as follows:
	8:	if source is 0 and destination is 0
	4:	if source is 0 and destination is 1
	2:	if source is 1 and destination is 0
	1:	if source is 1 and destination is 1.
At each pixel the corresponding bits of the source and destination pixel values determine one of these conditions;  if the combination rule has a 1 in the corresponding bit position, then the new destination value will be 1, otherwise it will be zero.  Forms may be of different depths, see the comment in class Form.

In addition to the original 16 combination rules, this BitBlt supports
	16	fails (to simulate paint bits)
	17	fails (to simulate erase bits)
	18	sourceWord + destinationWord
	19	sourceWord - destinationWord
	20	rgbAdd: sourceWord with: destinationWord.  Sum of color components
	21	rgbSub: sourceWord with: destinationWord.  Difference of color components
	22	OLDrgbDiff: sourceWord with: destinationWord.  Sum of abs of differences in components
	23	OLDtallyIntoMap: destinationWord.  Tallies pixValues into a colorMap
			these old versions don't do bitwise dest clipping.  Use 32 and 33 now.
	24	alphaBlend: sourceWord with: destinationWord.  32-bit source and dest only
	25	pixPaint: sourceWord with: destinationWord.  Wherever the sourceForm is non-zero, it replaces the destination.  Can be used with a 1-bit source color mapped to (0, FFFFFFFF), and a fillColor to fill the dest with that color wherever the source is 1.
	26	pixMask: sourceWord with: destinationWord.  Like pixPaint, but fills with 0.
	27	rgbMax: sourceWord with: destinationWord.  Max of each color component.
	28	rgbMin: sourceWord with: destinationWord.  Min of each color component.
	29	rgbMin: sourceWord bitInvert32 with: destinationWord.  Min with (max-source)
	30	alphaBlendConst: sourceWord with: destinationWord.  alpha is an arg. works in 16 bits.
	31	alphaPaintConst: sourceWord with: destinationWord.  alpha is an arg. works in 16 bits.
	32	rgbDiff: sourceWord with: destinationWord.  Sum of abs of differences in components
	33	tallyIntoMap: destinationWord.  Tallies pixValues into a colorMap
	34	alphaBlendScaled: srcWord with: dstWord. Alpha blend of scaled srcWord and destWord.

The color specified by halftoneForm may be either a Color or a Pattern.   A Color is converted to a pixelValue for the depth of the destinationForm.  If a Pattern, BitBlt will simply interpret its bitmap as an array of Color pixelValues.  BitBlt aligns the first element of this array with the top scanline of the destinationForm, the second with the second, and so on, cycling through the color array as necessary.  Within each scan line the 32-bit value is repeated from left to right across the form.  If the value repeats on pixels boudaries, the effect will be a constant color;  if not, it will produce a halftone that repeats on 32-bit boundaries.

Any transfer specified is further clipped by the specified rectangle (clipX, clipY, clipWidth, clipHeight), and also by the bounds of the source and destination forms.
	To make a small Form repeat and fill a big form, use an InfiniteForm as the source.
	To write on a form and leave with both transparent and opapue areas, use a MaskedForm as the source.

Pixels from a source to a destination whose pixels have a different depth are converted based on the optional colorMap.  If colorMap is nil, then conversion to more bits is done by filling the new high-order bits with zero, and conversion to fewer bits is done by truncating the lost high-order bits.  

The colorMap, if specified, must be a either word array (ie Bitmap) with 2^n elements, where n is the pixel depth of the source, or a fully specified ColorMap which may contain a lookup table (ie Bitmap) and/or four separate masks and shifts which are applied to the pixels. For every source pixel, BitBlt will first perform masking and shifting and then index the lookup table, and select the corresponding pixelValue and mask it to the destination pixel size before storing.
	When blitting from a 32 or 16 bit deep Form to one 8 bits or less, the default is truncation.  This will produce very strange colors, since truncation of the high bits does not produce the nearest encoded color.  Supply a 512 long colorMap, and red, green, and blue will be shifted down to 3 bits each, and mapped.  The message copybits...stdColors will use the best map to the standard colors for destinations of depths 8, 4, 2 and 1.  Two other sized of colorMaps are allowed, 4096 (4 bits per color) and 32786 (five bits per color).
	Normal blits between 16 and 32 bit forms truncates or pads the colors automatically to provide the best preservation of colors.
	Colors can be remapped at the same depth.  Sometimes a Form is in terms of colors that are not the standard colors for this depth, for example in a GIF file.  Convert the Form to a MaskedForm and send colorMap: the list of colors that the picture is in terms of.  MaskedForm will use the colorMap when copying to the display or another Form. (Note also that a Form can be copied to itself, and transformed in the process, if a non-nil colorMap is supplied.)
"""

</t>
<t tx="karstenw.20210225165727.3"></t>
<t tx="karstenw.20210225165727.4">"""
BitBlt class
	instanceVariableNames: ''!

!BitBlt class methodsFor: 'instance creation' stamp: 'ar 5/28/2000 12:04'!
asGrafPort
	"Return the GrafPort associated with the receiver"
	^GrafPort! !

!BitBlt class methodsFor: 'instance creation' stamp: 'di 3/2/98 12:53'!
bitPeekerFromForm: sourceForm
	"Answer an instance to be used extract individual pixels from the given Form. The destination for a 1x1 copyBits will be the low order bits of (bits at: 1)."
	| pixPerWord |
	pixPerWord _ 32 // sourceForm depth.
	sourceForm unhibernate.
	^ self destForm: (Form extent: pixPerWord@1 depth: sourceForm depth)
	 	sourceForm: sourceForm
		halftoneForm: nil
		combinationRule: Form over
		destOrigin: (pixPerWord - 1)@0
		sourceOrigin: 0@0
		extent: 1@1
		clipRect: (0@0 extent: pixPerWord@1)
! !

!BitBlt class methodsFor: 'instance creation' stamp: 'di 3/2/98 12:53'!
bitPokerToForm: destForm
	"Answer an instance to be used for valueAt: aPoint put: pixValue.
	The source for a 1x1 copyBits will be the low order of (bits at: 1)"
	| pixPerWord |
	pixPerWord _ 32//destForm depth.
	destForm unhibernate.
	^ self destForm: destForm
	 	sourceForm: (Form extent: pixPerWord@1 depth: destForm depth)
		halftoneForm: nil combinationRule: Form over
		destOrigin: 0@0 sourceOrigin: (pixPerWord-1)@0
		extent: 1@1 clipRect: (0@0 extent: destForm extent)
! !

!BitBlt class methodsFor: 'instance creation' stamp: 'ar 5/28/2000 12:00'!
current
	"Return the class currently to be used for BitBlt"
	^Display defaultBitBltClass! !

!BitBlt class methodsFor: 'instance creation'!
destForm: df sourceForm: sf fillColor: hf combinationRule: cr destOrigin: destOrigin sourceOrigin: sourceOrigin extent: extent clipRect: clipRect 
	"Answer an instance of me with values set according to the arguments."

	^ self new
		setDestForm: df
		sourceForm: sf
		fillColor: hf
		combinationRule: cr
		destOrigin: destOrigin
		sourceOrigin: sourceOrigin
		extent: extent
		clipRect: clipRect! !

!BitBlt class methodsFor: 'instance creation'!
destForm: df sourceForm: sf halftoneForm: hf combinationRule: cr destOrigin: destOrigin sourceOrigin: sourceOrigin extent: extent clipRect: clipRect 
	"Answer an instance of me with values set according to the arguments."

	^ self new
		setDestForm: df
		sourceForm: sf
		fillColor: hf
		combinationRule: cr
		destOrigin: destOrigin
		sourceOrigin: sourceOrigin
		extent: extent
		clipRect: clipRect! !

!BitBlt class methodsFor: 'instance creation'!
toForm: aForm
	^ self new setDestForm: aForm! !
"""
</t>
<t tx="karstenw.20210225165727.5">"""
!BitBlt class methodsFor: 'examples' stamp: 'di 12/1/97 12:08'!
alphaBlendDemo
	"To run this demo, use...
		Display restoreAfter: [BitBlt alphaBlendDemo]	
	Displays 10 alphas, then lets you paint.  Option-Click to stop painting."

	"This code exhibits alpha blending in any display depth by performing
	the blend in an off-screen buffer with 32-bit pixels, and then copying
	the result back onto the screen with an appropriate color map. - tk 3/10/97"
	
	"This version uses a sliding buffer for painting that keeps pixels in 32 bits
	as long as they are in the buffer, so as not to lose info by converting down
	to display resolution and back up to 32 bits at each operation. - di 3/15/97"

	| brush buff dispToBuff buffToDisplay mapDto32 map32toD prevP p brushToBuff theta buffRect buffSize buffToBuff brushRect delta newBuffRect updateRect |  

	"compute color maps if needed"
	Display depth &lt;= 8 ifTrue: [
		mapDto32 _ Color cachedColormapFrom: Display depth to: 32.
		map32toD _ Color cachedColormapFrom: 32 to: Display depth].

	"display 10 different alphas, across top of screen"
	buff _ Form extent: 500@50 depth: 32.
	dispToBuff _ BitBlt toForm: buff.
	dispToBuff colorMap: mapDto32.
	dispToBuff copyFrom: (50@10 extent: 500@50) in: Display to: 0@0.
	1 to: 10 do: [:i | dispToBuff fill: (50*(i-1)@0 extent: 50@50)
						fillColor: (Color red alpha: i/10)
						rule: Form blend].
	buffToDisplay _ BitBlt toForm: Display.
	buffToDisplay colorMap: map32toD.
	buffToDisplay copyFrom: buff boundingBox in: buff to: 50@10.

	"Create a brush with radially varying alpha"
	brush _ Form extent: 30@30 depth: 32.
	1 to: 5 do: 
		[:i | brush fillShape: (Form dotOfSize: brush width*(6-i)//5)
				fillColor: (Color red alpha: 0.02 * i - 0.01)
				at: brush extent // 2].

	"Now paint with the brush using alpha blending."
	buffSize _ 100.
	buff _ Form extent: brush extent + buffSize depth: 32.  "Travelling 32-bit buffer"
	dispToBuff _ BitBlt toForm: buff.  "This is from Display to buff"
	dispToBuff colorMap: mapDto32.
	brushToBuff _ BitBlt toForm: buff.  "This is from brush to buff"
	brushToBuff sourceForm: brush; sourceOrigin: 0@0.
	brushToBuff combinationRule: Form blend.
	buffToBuff _ BitBlt toForm: buff.  "This is for slewing the buffer"

	[Sensor yellowButtonPressed] whileFalse:
		[prevP _ nil.
		buffRect _ Sensor cursorPoint - (buffSize // 2) extent: buff extent.
		dispToBuff copyFrom: buffRect in: Display to: 0@0.
		[Sensor redButtonPressed] whileTrue:
			["Here is the painting loop"
			p _ Sensor cursorPoint - (brush extent // 2).
			(prevP == nil or: [prevP ~= p]) ifTrue:
				[prevP == nil ifTrue: [prevP _ p].
				(p dist: prevP) &gt; buffSize ifTrue:
					["Stroke too long to fit in buffer -- clip to buffer,
						and next time through will do more of it"
					theta _ (p-prevP) theta.
					p _ ((theta cos@theta sin) * buffSize asFloat + prevP) truncated].
				brushRect _ p extent: brush extent.
				(buffRect containsRect: brushRect) ifFalse:
					["Brush is out of buffer region.  Scroll the buffer,
						and fill vacated regions from the display"
					delta _ brushRect amountToTranslateWithin: buffRect.
					buffToBuff copyFrom: buff boundingBox in: buff to: delta.
					newBuffRect _ buffRect translateBy: delta negated.
					(newBuffRect areasOutside: buffRect) do:
						[:r | dispToBuff copyFrom: r in: Display to: r origin - newBuffRect origin].
					buffRect _ newBuffRect].

				"Interpolate from prevP to p..."
				brushToBuff drawFrom: prevP - buffRect origin
									to: p - buffRect origin
									withFirstPoint: false.

				"Update (only) the altered pixels of the destination"
				updateRect _ (p min: prevP) corner: (p max: prevP) + brush extent.
				buffToDisplay copy: updateRect from: updateRect origin - buffRect origin in: buff.
				prevP _ p]]]! !

!BitBlt class methodsFor: 'examples' stamp: 'di 12/1/97 12:09'!
antiAliasDemo 
	"To run this demo, use...
		Display restoreAfter: [BitBlt antiAliasDemo]
	Goes immediately into on-screen paint mode.  Option-Click to stop painting."

	"This code exhibits alpha blending in any display depth by performing
	the blend in an off-screen buffer with 32-bit pixels, and then copying
	the result back onto the screen with an appropriate color map. - tk 3/10/97"
	
	"This version uses a sliding buffer for painting that keeps pixels in 32 bits
	as long as they are in the buffer, so as not to lose info by converting down
	to display resolution and back up to 32 bits at each operation. - di 3/15/97"
	
	"This version also uses WarpBlt to paint into twice as large a buffer,
	and then use smoothing when reducing back down to the display.
	In fact this same routine will now work for 3x3 soothing as well.
	Remove the statements 'buff displayAt: 0@0' to hide the buffer. - di 3/19/97"

	| brush buff dispToBuff buffToDisplay mapDto32 map32toD prevP p brushToBuff theta buffRect buffSize buffToBuff brushRect delta newBuffRect updateRect scale p0 |  
	"compute color maps if needed"
	Display depth &lt;= 8 ifTrue: [
		mapDto32 _ Color cachedColormapFrom: Display depth to: 32.
		map32toD _ Color cachedColormapFrom: 32 to: Display depth].

	"Create a brush with radially varying alpha"
	brush _ Form extent: 3@3 depth: 32.
	brush fill: brush boundingBox fillColor: (Color red alpha: 0.05).
	brush fill: (1@1 extent: 1@1) fillColor: (Color red alpha: 0.2).

	scale _ 2.  "Actual drawing happens at this magnification"
	"Scale brush up for painting in magnified buffer"
	brush _ brush magnify: brush boundingBox by: scale.

	"Now paint with the brush using alpha blending."
	buffSize _ 100.
	buff _ Form extent: (brush extent + buffSize) * scale depth: 32.  "Travelling 32-bit buffer"
	dispToBuff _ (WarpBlt toForm: buff)  "From Display to buff - magnify by 2"
		sourceForm: Display;
		colorMap: mapDto32;
		combinationRule: Form over.
	brushToBuff _ (BitBlt toForm: buff)  "From brush to buff"
		sourceForm: brush;
		sourceOrigin: 0@0;
		combinationRule: Form blend.
	buffToDisplay _ (WarpBlt toForm: Display)  "From buff to Display - shrink by 2"
		sourceForm: buff;
		colorMap: map32toD;
		cellSize: scale;  "...and use smoothing"
		combinationRule: Form over.
	buffToBuff _ BitBlt toForm: buff.  "This is for slewing the buffer"

	[Sensor yellowButtonPressed] whileFalse:
		[prevP _ nil.
		buffRect _ Sensor cursorPoint - (buff extent // scale // 2) extent: buff extent // scale.
		p0 _ (buff extent // 2) - (buffRect extent // 2).
		dispToBuff copyQuad: buffRect innerCorners toRect: buff boundingBox.
buff displayAt: 0@0.  "** remove to hide sliding buffer **"
		[Sensor redButtonPressed] whileTrue:
			["Here is the painting loop"
			p _ Sensor cursorPoint - buffRect origin + p0.  "p, prevP are rel to buff origin"
			(prevP == nil or: [prevP ~= p]) ifTrue:
				[prevP == nil ifTrue: [prevP _ p].
				(p dist: prevP) &gt; (buffSize-1) ifTrue:
					["Stroke too long to fit in buffer -- clip to buffer,
						and next time through will do more of it"
					theta _ (p-prevP) theta.
					p _ ((theta cos@theta sin) * (buffSize-2) asFloat + prevP) truncated].
				brushRect _ p extent: brush extent.
				((buff boundingBox insetBy: scale) containsRect: brushRect) ifFalse:
					["Brush is out of buffer region.  Scroll the buffer,
						and fill vacated regions from the display"
					delta _ (brushRect amountToTranslateWithin: (buff boundingBox insetBy: scale)) // scale.
					buffToBuff copyFrom: buff boundingBox in: buff to: delta*scale.
					newBuffRect _ buffRect translateBy: delta negated.
					p _ p translateBy: delta*scale.
					prevP _ prevP translateBy: delta*scale.
					(newBuffRect areasOutside: buffRect) do:
						[:r | dispToBuff copyQuad: r innerCorners toRect: (r origin - newBuffRect origin*scale extent: r extent*scale)].
					buffRect _ newBuffRect].

				"Interpolate from prevP to p..."
				brushToBuff drawFrom: prevP to: p withFirstPoint: false.
buff displayAt: 0@0.  "** remove to hide sliding buffer **"

				"Update (only) the altered pixels of the destination"
				updateRect _ (p min: prevP) corner: (p max: prevP) + brush extent.
				updateRect _ updateRect origin // scale * scale
						corner: updateRect corner + scale // scale * scale.
				buffToDisplay copyQuad: updateRect innerCorners
							toRect: (updateRect origin // scale + buffRect origin
										extent: updateRect extent // scale).
				prevP _ p]]]! !

!BitBlt class methodsFor: 'examples' stamp: 'ar 5/4/2001 16:02'!
exampleColorMap	"BitBlt exampleColorMap"
	"This example shows what one can do with the fixed part of a color map. The color map, as setup below, rotates the bits of a pixel all the way around. Thus you'll get a (sometime strange looking ;-) animation of colors which will end up exactly the way it looked at the beginning. The example is given to make you understand that the masks and shifts can be used for a lot more than simply color converting pixels. In this example, for instance, we use only two of the four independent shifters."
	| cc bb |
	cc _ ColorMap masks: {
		1 &lt;&lt; (Display depth-1). "mask out high bit of color component"
		1 &lt;&lt; (Display depth-1) - 1. "mask all other bits"
		0.
		0}
		shifts: {
			1 - Display depth. "shift right to bottom most position"
			1. "shift all other pixels one bit left"
			0.
			0}.
	bb _ BitBlt toForm: Display.
	bb 
		sourceForm: Display;
		combinationRule: 3;
		colorMap: cc.
	1 to: Display depth do:[:i|
		bb copyBits.
		Display forceDisplayUpdate.
	].
! !

!BitBlt class methodsFor: 'examples' stamp: 'dew 9/18/2001 02:30'!
exampleOne
	"This tests BitBlt by displaying the result of all sixteen combination rules that BitBlt is capable of using. (Please see the comment in BitBlt for the meaning of the combination rules). This only works at Display depth of 1. (Rule 15 does not work?)"
	| path displayDepth |

	displayDepth _ Display depth.
	Display newDepth: 1.

	path _ Path new.
	0 to: 3 do: [:i | 0 to: 3 do: [:j | path add: j * 100 @ (i * 75)]].
	Display fillWhite.
	path _ path translateBy: 60 @ 40.
	1 to: 16 do: [:index | BitBlt
			exampleAt: (path at: index)
			rule: index - 1
			fillColor: nil].

	[Sensor anyButtonPressed] whileFalse: [].
	Display newDepth: displayDepth.

	"BitBlt exampleOne"! !

!BitBlt class methodsFor: 'examples' stamp: 'jrm 2/21/2001 23:43'!
exampleTwo
	"This is to test painting with a gray tone. It also tests that the seaming with gray patterns is correct in the microcode. Lets you paint for a while and then automatically stops. This only works at Depth of 1."
	| f aBitBlt displayDepth |
	"create a small black Form source as a brush. "
	displayDepth _ Display depth.
	Display newDepth: 1.
	f _ Form extent: 20 @ 20.
	f fillBlack.
	"create a BitBlt which will OR gray into the display. "
	aBitBlt _ BitBlt
		destForm: Display
		sourceForm: f
		fillColor: Color gray
		combinationRule: Form over
		destOrigin: Sensor cursorPoint
		sourceOrigin: 0 @ 0
		extent: f extent
		clipRect: Display computeBoundingBox.
	"paint the gray Form on the screen for a while. "
	[Sensor anyButtonPressed] whileFalse: 
		[aBitBlt destOrigin: Sensor cursorPoint.
		aBitBlt copyBits].
	Display newDepth: displayDepth.
	"BitBlt exampleTwo"! !
"""


</t>
<t tx="karstenw.20210225165727.6">"""
!BitBlt class methodsFor: 'private' stamp: 'jrm 2/21/2001 23:45'!
exampleAt: originPoint rule: rule fillColor: mask 
	"This builds a source and destination form and copies the source to the
	destination using the specifed rule and mask. It is called from the method
	named exampleOne. Only works with Display depth of 1"

	| s d border aBitBlt | 
	border_Form extent: 32@32.
	border fillBlack.
	border fill: (1@1 extent: 30@30) fillColor: Color white.
	s _ Form extent: 32@32.
	s fillWhite.
	s fillBlack: (7@7 corner: 25@25).
	d _ Form extent: 32@32.
	d fillWhite.
	d fillBlack: (0@0 corner: 32@16).

	s displayOn: Display at: originPoint.
	border displayOn: Display at: originPoint rule: Form under.
	d displayOn: Display at: originPoint + (s width @0).
	border displayOn: Display at: originPoint + (s width @0) rule: Form under.

	d displayOn: Display at: originPoint + (s extent // (2 @ 1)). 
	aBitBlt _ BitBlt
		destForm: Display
		sourceForm: s
		fillColor: mask
		combinationRule: rule
		destOrigin: originPoint + (s extent // (2 @ 1))
		sourceOrigin: 0 @ 0
		extent: s extent
		clipRect: Display computeBoundingBox.
	aBitBlt copyBits.
	border 
		displayOn: Display at: originPoint + (s extent // (2 @ 1))
		rule: Form under.

	"BitBlt exampleAt: 100@100 rule: 0 fillColor: nil"  ! !
"""
</t>
<t tx="karstenw.20210225165727.7">"""
!BitBlt class methodsFor: 'benchmarks' stamp: 'ar 4/24/2001 23:49'!
benchDiffsFrom: before to: afterwards
	"Given two outputs of BitBlt&gt;&gt;benchmark show the relative improvements."
	| old new log oldLine newLine oldVal newVal improvement |
	log _ WriteStream on: String new.
	old _ ReadStream on: before.
	new _ ReadStream on: afterwards.
	[old atEnd or:[new atEnd]] whileFalse:[
		oldLine _ old upTo: Character cr.
		newLine _ new upTo: Character cr.
		(oldLine includes: Character tab) ifTrue:[
			oldLine _ ReadStream on: oldLine.
			newLine _ ReadStream on: newLine.
			Transcript cr; show: (oldLine upTo: Character tab); tab.
			log cr; nextPutAll: (newLine upTo: Character tab); tab.

			[oldLine skipSeparators. newLine skipSeparators.
			oldLine atEnd] whileFalse:[
				oldVal _ Integer readFrom: oldLine.
				newVal _ Integer readFrom: newLine.
				improvement _ oldVal asFloat / newVal asFloat roundTo: 0.01.
				Transcript show: improvement printString; tab; tab.
				log print: improvement; tab; tab].
		] ifFalse:[
			Transcript cr; show: oldLine.
			log cr; nextPutAll: oldLine.
		].
	].
	^log contents! !

!BitBlt class methodsFor: 'benchmarks' stamp: 'ar 5/14/2001 23:31'!
benchmark		"BitBlt benchmark"
	"Run a benchmark on different combinations rules, source/destination depths and BitBlt modes. Note: This benchmark doesn't give you any 'absolute' value - it is intended only for benchmarking improvements in the bitblt code and nothing else.
	Attention: *this*may*take*a*while*"
	| bb source dest destRect log t |
	log _ WriteStream on: String new.
	destRect _ 0@0 extent: 600@600.
	"Form paint/Form over - the most common rules"
	#( 25 3 ) do:[:rule|
		Transcript cr; show:'---- Combination rule: ', rule printString,' ----'.
		log cr; nextPutAll:'---- Combination rule: ', rule printString,' ----'.
		#(1 2 4 8 16 32) do:[:destDepth|
			dest _ nil.
			dest _ Form extent: destRect extent depth: destDepth.
			Transcript cr.
			log cr.
			#(1 2 4 8 16 32) do:[:sourceDepth|
				Transcript cr; show: sourceDepth printString, ' =&gt; ', destDepth printString.
				log cr; nextPutAll: sourceDepth printString, ' =&gt; ', destDepth printString.
				source _ nil. bb _ nil.
				source _ Form extent: destRect extent depth: sourceDepth.
				(source getCanvas) fillOval: dest boundingBox color: Color yellow borderWidth: 30 borderColor: Color black.
				bb _ WarpBlt toForm: dest.
				bb sourceForm: source.
				bb sourceRect: source boundingBox.
				bb destRect: dest boundingBox.
				bb colorMap: (source colormapIfNeededFor: dest).
				bb combinationRule: rule.

				"Measure speed of copyBits"
				t _ Time millisecondsToRun:[bb copyBits].
				Transcript tab; show: t printString.
				log tab; nextPutAll: t printString.

				bb sourceForm: source destRect: source boundingBox.

				"Measure speed of 1x1 warpBits"
				bb cellSize: 1.
				t _ Time millisecondsToRun:[bb warpBits].
				Transcript tab; show: t printString.
				log tab; nextPutAll: t printString.

				"Measure speed of 2x2 warpBits"
				bb cellSize: 2.
				t _ Time millisecondsToRun:[bb warpBits].
				Transcript tab; show: t printString.
				log tab; nextPutAll: t printString.

				"Measure speed of 3x3 warpBits"
				bb cellSize: 3.
				t _ Time millisecondsToRun:[bb warpBits].
				Transcript tab; show: t printString.
				log tab; nextPutAll: t printString.
			].
		].
	].
	^log contents! !

!BitBlt class methodsFor: 'benchmarks' stamp: 'ar 5/14/2001 23:31'!
benchmark2		"BitBlt benchmark"
	"Run a benchmark on different combinations rules, source/destination depths and BitBlt modes. Note: This benchmark doesn't give you any 'absolute' value - it is intended only for benchmarking improvements in the bitblt code and nothing else.
	Attention: *this*may*take*a*while*"
	| bb source dest destRect log t |
	log _ WriteStream on: String new.
	destRect _ 0@0 extent: 600@600.
	"Form paint/Form over - the most common rules"
	#( 25 3 ) do:[:rule|
		Transcript cr; show:'---- Combination rule: ', rule printString,' ----'.
		log cr; nextPutAll:'---- Combination rule: ', rule printString,' ----'.
		#(1 2 4 8 16 32) do:[:destDepth|
			dest _ nil.
			dest _ Form extent: destRect extent depth: destDepth.
			Transcript cr.
			log cr.
			#(1 2 4 8 16 32) do:[:sourceDepth|
				Transcript cr; show: sourceDepth printString, ' =&gt; ', destDepth printString.
				log cr; nextPutAll: sourceDepth printString, ' =&gt; ', destDepth printString.
				source _ nil. bb _ nil.
				source _ Form extent: destRect extent depth: sourceDepth.
				(source getCanvas) fillOval: dest boundingBox color: Color yellow borderWidth: 30 borderColor: Color black.
				bb _ WarpBlt toForm: dest.
				bb sourceForm: source.
				bb sourceRect: source boundingBox.
				bb destRect: dest boundingBox.
				bb colorMap: (source colormapIfNeededFor: dest).
				bb combinationRule: rule.

				"Measure speed of copyBits"
				t _ Time millisecondsToRun:[1 to: 10 do:[:i| bb copyBits]].
				Transcript tab; show: t printString.
				log tab; nextPutAll: t printString.

				bb sourceForm: source destRect: source boundingBox.

				"Measure speed of 1x1 warpBits"
				bb cellSize: 1.
				t _ Time millisecondsToRun:[1 to: 4 do:[:i| bb warpBits]].
				Transcript tab; show: t printString.
				log tab; nextPutAll: t printString.

				"Measure speed of 2x2 warpBits"
				bb cellSize: 2.
				t _ Time millisecondsToRun:[bb warpBits].
				Transcript tab; show: t printString.
				log tab; nextPutAll: t printString.

				"Measure speed of 3x3 warpBits"
				bb cellSize: 3.
				t _ Time millisecondsToRun:[bb warpBits].
				Transcript tab; show: t printString.
				log tab; nextPutAll: t printString.
			].
		].
	].
	^log contents! !

!BitBlt class methodsFor: 'benchmarks' stamp: 'ar 4/26/2001 21:04'!
benchmark3		"BitBlt benchmark"
	"Run a benchmark on different combinations rules, source/destination depths and BitBlt modes. Note: This benchmark doesn't give you any 'absolute' value - it is intended only for benchmarking improvements in the bitblt code and nothing else.
	Attention: *this*may*take*a*while*"
	| bb source dest destRect log t |
	log _ WriteStream on: String new.
	destRect _ 0@0 extent: 600@600.
	"Form paint/Form over - the most common rules"
	#( 25 3 ) do:[:rule|
		Transcript cr; show:'---- Combination rule: ', rule printString,' ----'.
		log cr; nextPutAll:'---- Combination rule: ', rule printString,' ----'.
		#(1 2 4 8 16 32) do:[:destDepth|
			dest _ nil.
			dest _ Form extent: destRect extent depth: destDepth.
			Transcript cr.
			log cr.
			#(1 2 4 8 16 32) do:[:sourceDepth|
				Transcript cr; show: sourceDepth printString, ' =&gt; ', destDepth printString.
				log cr; nextPutAll: sourceDepth printString, ' =&gt; ', destDepth printString.
				source _ nil. bb _ nil.
				source _ Form extent: destRect extent depth: sourceDepth.
				(source getCanvas) fillOval: dest boundingBox color: Color yellow borderWidth: 30 borderColor: Color black.
				bb _ WarpBlt toForm: dest.
				bb sourceForm: source.
				bb sourceRect: source boundingBox.
				bb destRect: dest boundingBox.
				bb colorMap: (source colormapIfNeededFor: dest).
				bb combinationRule: rule.

				"Measure speed of copyBits"
				t _ Time millisecondsToRun:[1 to: 10 do:[:i| bb copyBits]].
				Transcript tab; show: t printString.
				log tab; nextPutAll: t printString.

				bb sourceForm: source destRect: source boundingBox.

				"Measure speed of 1x1 warpBits"
				bb cellSize: 1.
				t _ Time millisecondsToRun:[1 to: 4 do:[:i| bb warpBits]].
				Transcript tab; show: t printString.
				log tab; nextPutAll: t printString.

				"Measure speed of 2x2 warpBits"
				bb cellSize: 2.
				t _ Time millisecondsToRun:[bb warpBits].
				Transcript tab; show: t printString.
				log tab; nextPutAll: t printString.

				"Measure speed of 3x3 warpBits"
				bb cellSize: 3.
				t _ Time millisecondsToRun:[bb warpBits].
				Transcript tab; show: t printString.
				log tab; nextPutAll: t printString.
			].
		].
	].
	^log contents! !
"""
</t>
<t tx="karstenw.20210225165727.8"></t>
<t tx="karstenw.20210225165727.9">@
!BitBlt methodsFor: 'accessing' stamp: 'ar 12/30/2001 20:31'!
clipBy: aRectangle
	| aPoint right bottom |
	right _ clipX + clipWidth.
	bottom _ clipY + clipHeight.
	aPoint _ aRectangle origin.
	aPoint x &gt; clipX ifTrue:[clipX _ aPoint x].
	aPoint y &gt; clipY ifTrue:[clipY _ aPoint y].
	aPoint _ aRectangle corner.
	aPoint x &lt; right ifTrue:[right _ aPoint x].
	aPoint y &lt; bottom ifTrue:[bottom _ aPoint y].
	clipWidth _ right - clipX.
	clipHeight _ bottom - clipY.
	clipWidth &lt; 0 ifTrue:[clipWidth _ 0].
	clipHeight &lt; 0 ifTrue:[clipHeight _ 0].! !

!BitBlt methodsFor: 'accessing' stamp: 'ar 12/30/2001 20:33'!
clipByX1: x1 y1: y1 x2: x2 y2: y2
	| right bottom |
	right _ clipX + clipWidth.
	bottom _ clipY + clipHeight.
	x1 &gt; clipX ifTrue:[clipX _ x1].
	y1 &gt; clipY ifTrue:[clipY _ y1].
	x2 &lt; right ifTrue:[right _ x2].
	y2 &lt; bottom ifTrue:[bottom _ y2].
	clipWidth _ right - clipX.
	clipHeight _ bottom - clipY.
	clipWidth &lt; 0 ifTrue:[clipWidth _ 0].
	clipHeight &lt; 0 ifTrue:[clipHeight _ 0].! !

!BitBlt methodsFor: 'accessing' stamp: 'ar 5/17/2000 18:58'!
clipHeight
	^clipHeight! !

!BitBlt methodsFor: 'accessing' stamp: 'ar 5/17/2000 18:58'!
clipHeight: anInteger 
	"Set the receiver's clipping area height to be the argument, anInteger."

	clipHeight _ anInteger! !

!BitBlt methodsFor: 'accessing'!
clipRect
	"Answer the receiver's clipping area rectangle."

	^clipX @ clipY extent: clipWidth @ clipHeight! !

!BitBlt methodsFor: 'accessing' stamp: 'ar 10/4/2000 16:37'!
clipRect: aRectangle 
	"Set the receiver's clipping area rectangle to be the argument, aRectangle."

	clipX _ aRectangle left truncated.
	clipY _ aRectangle top truncated.
	clipWidth _ aRectangle right truncated - clipX.
	clipHeight _ aRectangle bottom truncated - clipY.! !

!BitBlt methodsFor: 'accessing' stamp: 'ar 5/17/2000 18:58'!
clipWidth
	^clipWidth! !

!BitBlt methodsFor: 'accessing' stamp: 'ar 5/17/2000 18:58'!
clipWidth: anInteger 
	"Set the receiver's clipping area width to be the argument, anInteger."

	clipWidth _ anInteger! !

!BitBlt methodsFor: 'accessing' stamp: 'ar 5/17/2000 18:58'!
clipX
	^clipX! !

!BitBlt methodsFor: 'accessing' stamp: 'ar 5/17/2000 18:58'!
clipX: anInteger 
	"Set the receiver's clipping area top left x coordinate to be the argument, 
	anInteger."

	clipX _ anInteger! !

!BitBlt methodsFor: 'accessing' stamp: 'ar 5/17/2000 18:58'!
clipY
	^clipY! !

!BitBlt methodsFor: 'accessing' stamp: 'ar 5/17/2000 18:58'!
clipY: anInteger 
	"Set the receiver's clipping area top left y coordinate to be the argument, 
	anInteger."

	clipY _ anInteger! !

!BitBlt methodsFor: 'accessing' stamp: 'tk 8/15/2001 10:56'!
color
	"Return the current fill color as a Color.  
	 Gives the wrong answer if the halftoneForm is a complex pattern of more than one word."

	halftoneForm ifNil: [^ Color black].
	^ Color colorFromPixelValue: halftoneForm first depth: destForm depth! !

!BitBlt methodsFor: 'accessing'!
colorMap
	^ colorMap! !

!BitBlt methodsFor: 'accessing' stamp: 'ar 5/4/2001 15:45'!
colorMap: map
	"See last part of BitBlt comment. 6/18/96 tk"
	colorMap _ map.! !

!BitBlt methodsFor: 'accessing'!
combinationRule: anInteger 
	"Set the receiver's combination rule to be the argument, anInteger, a 
	number in the range 0-15."

	combinationRule _ anInteger! !

!BitBlt methodsFor: 'accessing'!
destForm
	^ destForm! !

!BitBlt methodsFor: 'accessing'!
destOrigin: aPoint 
	"Set the receiver's destination top left coordinates to be those of the 
	argument, aPoint."

	destX _ aPoint x.
	destY _ aPoint y! !

!BitBlt methodsFor: 'accessing' stamp: 'tk 3/19/97'!
destRect
	"The rectangle we are about to blit to or just blitted to.  "

	^ destX @ destY extent: width @ height! !

!BitBlt methodsFor: 'accessing'!
destRect: aRectangle 
	"Set the receiver's destination form top left coordinates to be the origin of 
	the argument, aRectangle, and set the width and height of the receiver's 
	destination form to be the width and height of aRectangle."

	destX _ aRectangle left.
	destY _ aRectangle top.
	width _ aRectangle width.
	height _ aRectangle height! !

!BitBlt methodsFor: 'accessing'!
destX: anInteger 
	"Set the top left x coordinate of the receiver's destination form to be the 
	argument, anInteger."

	destX _ anInteger! !

!BitBlt methodsFor: 'accessing'!
destX: x destY: y width: w height: h
	"Combined init message saves 3 sends from DisplayScanner"
	destX _ x.
	destY _ y.
	width _ w.
	height _ h.! !

!BitBlt methodsFor: 'accessing'!
destY: anInteger 
	"Set the top left y coordinate of the receiver's destination form to be the 
	argument, anInteger."

	destY _ anInteger! !

!BitBlt methodsFor: 'accessing'!
fillColor
	^ halftoneForm! !

!BitBlt methodsFor: 'accessing' stamp: 'ar 5/14/2001 23:25'!
fillColor: aColorOrPattern 
	"The destForm will be filled with this color or pattern of colors.  May be an old Color, a new type Color, a Bitmap (see BitBlt comment), a Pattern, or a Form.  6/18/96 tk"

	aColorOrPattern == nil ifTrue: [halftoneForm _ nil. ^ self].
	destForm == nil ifTrue: [self error: 'Must set destForm first'].
	halftoneForm _ destForm bitPatternFor: aColorOrPattern ! !

!BitBlt methodsFor: 'accessing' stamp: 'tbn 9/14/2004 20:38'!
halftoneForm
	"Returns the receivers half tone form. See class commment."
	
	^halftoneForm! !

!BitBlt methodsFor: 'accessing' stamp: 'tbn 9/14/2004 20:39'!
halftoneForm: aBitmap
	"Sets the receivers half tone form. See class commment."
	
	halftoneForm := aBitmap
	
 ! !

!BitBlt methodsFor: 'accessing'!
height: anInteger 
	"Set the receiver's destination form height to be the argument, anInteger."

	height _ anInteger! !

!BitBlt methodsFor: 'accessing' stamp: 'ar 2/21/2000 22:06'!
sourceForm

	^ sourceForm! !

!BitBlt methodsFor: 'accessing'!
sourceForm: aForm 
	"Set the receiver's source form to be the argument, aForm."

	sourceForm _ aForm! !

!BitBlt methodsFor: 'accessing'!
sourceOrigin: aPoint 
	"Set the receiver's source form coordinates to be those of the argument, 
	aPoint."

	sourceX _ aPoint x.
	sourceY _ aPoint y! !

!BitBlt methodsFor: 'accessing'!
sourceRect: aRectangle 
	"Set the receiver's source form top left x and y, width and height to be 
	the top left coordinate and extent of the argument, aRectangle."

	sourceX _ aRectangle left.
	sourceY _ aRectangle top.
	width _ aRectangle width.
	height _ aRectangle height! !

!BitBlt methodsFor: 'accessing'!
sourceX: anInteger 
	"Set the receiver's source form top left x to be the argument, anInteger."

	sourceX _ anInteger! !

!BitBlt methodsFor: 'accessing'!
sourceY: anInteger 
	"Set the receiver's source form top left y to be the argument, anInteger."

	sourceY _ anInteger! !

!BitBlt methodsFor: 'accessing' stamp: 'ar 5/25/2000 19:39'!
tallyMap
	"Return the map used for tallying pixels"
	^colorMap! !

!BitBlt methodsFor: 'accessing' stamp: 'ar 5/25/2000 19:39'!
tallyMap: aBitmap
	"Install the map used for tallying pixels"
	colorMap _ aBitmap! !

!BitBlt methodsFor: 'accessing'!
width: anInteger 
	"Set the receiver's destination form width to be the argument, anInteger."

	width _ anInteger! !
</t>
</tnodes>
</leo_file>
